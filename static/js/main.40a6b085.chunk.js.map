{"version":3,"sources":["game/utils/utils.ts","game/constants.ts","game/objects/stars/stars.ts","game/objects/hitbox.ts","game/utils/easing.ts","game/objects/center.ts","game/controls/polyControls.ts","game/controls/keyboardControls.ts","game/clock/PolyClock.ts","game/controls/objectController.ts","game/objects/ship/ship.ts","game/objects/followCamera.ts","game/renderer.ts","game/scene/PolyScene.ts","game/objects/asteroid/asteroid.ts","game/objects/asteroid/meshFactory.ts","game/collider.ts","game/objects/asteroid/manager.ts","game/objects/followMissile/followMissile.ts","game/objects/followMissile/meshFactory.ts","game/objects/followMissile/manager.ts","game/objects/shots/shot.ts","game/objects/shots/meshFactory.ts","game/objects/shots/manager.ts","game/objects/explosion/meshFactory.ts","game/objects/explosion/explosion.ts","game/objects/explosion/manager.ts","game/polybius.ts","hooks/usePolybius.ts","hooks/useLazyRef.ts","App.tsx","index.tsx"],"names":["repeat","THREE","times","f","i","MathUtils","randFloat","min","max","Math","random","randomUnitVector","normalize","chance","p","getDumpster","CENTER_RADIUS","isNil","value","undefined","assertExists","msg","UnexpectedNilError","Error","noop","getOne","set","values","next","Stars","mesh","createStarsGeometry","starsGeometry","vertex","distance","multiplyScalar","vertices","push","this","color","size","sizeAttenuation","forEach","material","geometry","stars","matrixAutoUpdate","updateMatrix","add","PolyHitbox","followedObject","shape","hitboxDebug","debug","scene","radius","wireframe","update","objectPosition","position","clone","center","copy","intersects","hitbox","intersectsSphere","internalGeometry","computeBoundingSphere","boundingSphere","NoCollisionsHitbox","linearMap","x","a1","a2","b1","b2","mapLinear","constrain01","lo","hi","constrain","Movements","Center","clock","elapsed","getElapsed","scale","sin","centerMesh","getIdleMoveState","up","down","left","right","forwards","backwards","rollLeft","rollRight","shoot","KeyboardControls","moveState","keyMapping","bindKey","key","movement","attachListeners","window","addEventListener","keyDownHandler","keyUpHandler","dispose","e","get","code","Map","getDefaultKeyMapping","PolyClock","delta","getDelta","tick","getElapsedTime","ObjectController","controls","object","shots","shotDelta","orbitSpeed","rollSpeed","forwardsAndBackwardsSpeed","inertiaFactor","shotRecoveryTime","moveState1","moveState2","factor","lerp","lerpMoveStates","updateDepth","updateOrbit","updateShots","depthMovement","abs","zOffset","objectRadius","length","setLength","xAxis","yAxis","zAxis","matrix","extractBasis","verticalOrbit","horizontalOrbit","verticalVector","horizontalVector","directionVector","addVectors","clampLength","rotationAngle","applyAxisAngle","roll","lookAt","spawn","PolyShip","onCollide","who","console","log","createGeometry","frontPoint","backTop","backLeft","backRight","Float32Array","setAttribute","FollowCamera","innerWidth","innerHeight","followedPosition","newPosition","lerpVectors","BLOOM_PARAMS","PolyRenderer","camera","renderer","composer","getDomElement","domElement","resize","setSize","render","toneMappingExposure","pow","outputEncoding","renderScene","RenderPass","bloomPass","UnrealBloomPass","EffectComposer","renderToScreen","addPass","PolyScene","remove","fog","light","Asteroid","meshFactory","explosions","dropObject","normal","angularVelocity","radialVelocity","epoch","drop","easedTimeFactor","c4","PI","easeOutElastic","angleToRotate","currentLength","lengthOffset","buildMesh","getHitboxGeometry","Groups","AsteroidMeshFactory","hitboxGeometry","PolyCollider","rules","groups","addRule","g1","g2","addObjectToGroup","obj","group","removeObjectFromGroup","delete","o1","o2","polyObjectsCollide","Set","asteroids","ship","missiles","AsteroidManager","collider","idleObjects","liveObjects","intervalId","start","setInterval","spawnRandom","objectToSpawn","objectToDelete","clearTimeout","vec","mostPerpendicular","reduce","best","current","dot","negate","crossVectors","randomOrthogonalUnitVector","_","FollowMissile","direction","angSpeed","speed","align","updateRotation","updatePosition","updateFlames","towards","sub","angle","angleTo","clampedAngle","clamp","step","children","y","rotateY","cos","lookAtPos","rotateOnAxis","MissileMeshFactory","misilMaterial","fireGeom","lightFireMat","darkFireMat","lightFire","darkFire","rotateX","FollowMissileManager","initialPosition","clearInterval","Shot","ShotMeshFactory","coreGeometry","coreMaterial","coreMesh","ShotManager","FRAGMENT_INITIAL_COLOR","FRAGMENT_END_COLOR","ExplosionMeshFactory","fragmentMaterial","transparent","groupMesh","fragmentSize","fragmentGeometry","fragmentMesh","Explosion","fragmentSpeeds","getRandomSpeeds","fragmentObject","lifeTime","opacity","colorFactor","idx","fragment","dir","map","ExplosionsManager","Polybius","objectController","message","animate","removeEventListener","aspect","updateProjectionMatrix","requestAnimationFrame","usePolybius","polybius","init","ref","useRef","useLazyRef","useEffect","element","appendChild","App","useState","isPlaying","setIsPlaying","Game","StartScreen","startGame","polybiusRef","className","props","onClick","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.40a6b085.chunk.js","sourcesContent":["import * as THREE from 'three';\nimport { CENTER_RADIUS } from '../constants';\n\ntype RepeatFunction = (index: number) => void;\nexport const repeat = (times: number, f: RepeatFunction) => {\n    for (let i = 0; i < times; i++) {\n        f(i);\n    }\n};\n\nexport const MathUtils = THREE.MathUtils;\n\nexport function randFloat(min: number, max: number) {\n    return Math.random() * (max - min) + min;\n}\n\nexport const randomUnitVector = (): THREE.Vector3 => {\n    return new THREE.Vector3(randFloat(-1, 1), randFloat(-1, 1), randFloat(-1, 1)).normalize();\n};\n\nexport const randomOrthogonalUnitVector = (vec: THREE.Vector3): THREE.Vector3 => {\n    const x = new THREE.Vector3(1, 0, 0);\n    const y = new THREE.Vector3(0, 1, 0);\n    const z = new THREE.Vector3(0, 0, 1);\n\n    const mostPerpendicular = [y, z].reduce((best, current) => {\n        if (vec.dot(best) > vec.dot(current)) {\n            return current;\n        }\n        return best;\n    }, x);\n\n    if (chance(0.5)) {\n        mostPerpendicular.negate();\n    }\n\n    return new THREE.Vector3().crossVectors(vec, mostPerpendicular);\n};\n\nexport const randomTinyVector = (): THREE.Vector3 => {\n    return randomUnitVector().setLength(0.00001);\n};\n\nexport const getOrigin = (): THREE.Vector3 => {\n    return new THREE.Vector3(0, 0, 0);\n};\n\nexport const chance = (p: number): boolean => {\n    return randFloat(0, 1) < p;\n};\n\n// The dumpster has to be very, very far from the center so the camera doesn't catch it.\nconst DUMPSTER_POSITION = CENTER_RADIUS * 1000;\nexport const getDumpster = (): THREE.Vector3 => {\n    return new THREE.Vector3(DUMPSTER_POSITION, DUMPSTER_POSITION, DUMPSTER_POSITION);\n};\n\nexport type nil = undefined | null;\n\nexport const isNil = (value: any): value is nil => {\n    return value === undefined || value === null;\n};\n\nexport const assertExists = <T>(value: T | nil, msg?: string): T => {\n    if (isNil(value)) {\n        throw new UnexpectedNilError(msg);\n    } else {\n        return value;\n    }\n};\n\nexport class UnexpectedNilError extends Error {\n    constructor(msg?: string) {\n        super(msg ?? 'Unexpected nil value!');\n    }\n}\n\nexport const consoleInfo = (message: string): void => {\n    const styles = `\n        background-color: #dadada;\n        color: #2b2bfa;\n        margin: 1em;\n        padding: 0.5em 1em;\n        border-radius: 9999px;\n        font-size: 14px;\n        text-align: center;\n        font-weight: 800;\n    `;\n    console.log(`%c${message}`, styles);\n};\n\nexport const noop = () => {};\n\nexport const getOne = <T>(set: Set<T>): T | nil => {\n    return set.values().next().value;\n};\n","import * as THREE from 'three';\n\nexport const CENTER_RADIUS = 5;\nexport const MIN_RADIUS = 3 * CENTER_RADIUS;\nexport const MAX_RADIUS = 10 * CENTER_RADIUS;\n\nexport const CENTER = new THREE.Vector3();\n\nexport const ASTEROIDS_IN_SCENE = 50;\nexport const MISSILES_IN_SCENE = 50;\nexport const SHOTS_IN_SCENE = 20;\nexport const EXPLOSIONS_IN_SCENE = 50;\n","import * as THREE from 'three';\nimport { repeat, MathUtils } from '../../utils/utils';\nimport { CENTER_RADIUS } from '../../constants';\n\nexport class Stars {\n    public mesh: THREE.Group;\n\n    constructor() {\n        this.mesh = new THREE.Group();\n\n        const starsMaterials = [\n            new THREE.PointsMaterial({\n                color: 0x555555,\n                size: 2,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x555555,\n                size: 1,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x333333,\n                size: 2,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x3a3a3a,\n                size: 1,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x1a1a1a,\n                size: 2,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x1a1a1a,\n                size: 1,\n                sizeAttenuation: false,\n            }),\n        ];\n\n        starsMaterials.forEach((material) => {\n            const geometry = this.createStarsGeometry();\n            const stars = new THREE.Points(geometry, material);\n            stars.matrixAutoUpdate = false;\n            stars.updateMatrix();\n\n            this.mesh.add(stars);\n        });\n    }\n\n    private createStarsGeometry = (): THREE.Geometry => {\n        const starsGeometry = new THREE.Geometry();\n\n        repeat(1000, (i: number) => {\n            const vertex = new THREE.Vector3(\n                MathUtils.randFloat(-1, 1),\n                MathUtils.randFloat(-1, 1),\n                MathUtils.randFloat(-1, 1)\n            );\n            const distance = MathUtils.randFloat(CENTER_RADIUS * 20, CENTER_RADIUS * 100);\n            vertex.multiplyScalar(distance);\n\n            starsGeometry.vertices.push(vertex);\n        });\n\n        return starsGeometry;\n    };\n}\n","import * as THREE from 'three';\nimport { assertExists, getDumpster, isNil } from '../utils/utils';\nimport { PolyScene } from '../scene/PolyScene';\n\nexport interface Hitbox {\n    intersects(hitbox: Hitbox): boolean;\n    shape: THREE.Sphere;\n}\n\nexport class PolyHitbox implements Hitbox {\n    readonly shape: THREE.Sphere;\n    private hitboxDebug: THREE.Mesh | null;\n\n    constructor(\n        private followedObject: THREE.Object3D,\n        geometry: THREE.Geometry | THREE.BufferGeometry\n    ) {\n        const internalGeometry = geometry.clone();\n        internalGeometry.computeBoundingSphere();\n        this.shape = assertExists(internalGeometry.boundingSphere);\n\n        this.hitboxDebug = null;\n\n        this.update();\n    }\n\n    debug = (scene: PolyScene): void => {\n        const geometry = new THREE.SphereBufferGeometry(this.shape.radius, 8, 6);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0x324ca8,\n            wireframe: true,\n        });\n\n        this.hitboxDebug = new THREE.Mesh(geometry, material);\n\n        scene.add(this.hitboxDebug);\n\n        this.update();\n    };\n\n    update = (): void => {\n        const objectPosition = this.followedObject.position.clone();\n        this.shape.center.copy(objectPosition);\n        if (!isNil(this.hitboxDebug)) {\n            this.hitboxDebug.position.copy(objectPosition);\n        }\n    };\n\n    intersects = (hitbox: Hitbox): boolean => {\n        return this.shape.intersectsSphere(hitbox.shape);\n    };\n}\n\nexport class NoCollisionsHitbox implements Hitbox {\n    readonly shape: THREE.Sphere = new THREE.Sphere(getDumpster(), 0);\n\n    intersects = (hitbox: Hitbox): boolean => {\n        return false;\n    };\n}\n","import * as THREE from 'three';\n\nexport function linearMap(x: number, a1: number, a2: number, b1: number, b2: number): number {\n    return THREE.MathUtils.mapLinear(x, a1, a2, b1, b2);\n}\n\nexport function constrain(x: number, lo: number, hi: number): number {\n    if (x < lo) {\n        return lo;\n    }\n\n    if (x > hi) {\n        return hi;\n    }\n\n    return x;\n}\n\nexport function constrain01(x: number): number {\n    return constrain(x, 0, 1);\n}\n\nexport function easeOutElastic(x: number): number {\n    const c4 = (2 * Math.PI) / 3;\n\n    return x === 0 ? 0 : x === 1 ? 1 : 2 ** (-10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;\n}\n","import * as THREE from 'three';\nimport { PolyObject } from './polyObject';\nimport { CENTER_RADIUS } from '../constants';\nimport { PolyHitbox } from './hitbox';\nimport { PolyClock } from '../clock/PolyClock';\nimport { linearMap } from '../utils/easing';\n\nexport class Center implements PolyObject {\n    public mesh: THREE.Group;\n    public hitbox: PolyHitbox;\n\n    constructor(private clock: PolyClock) {\n        this.mesh = new THREE.Group();\n\n        const geometry = new THREE.SphereBufferGeometry(CENTER_RADIUS, 16, 12);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0xfa2b2b,\n            wireframe: true,\n        });\n\n        const centerMesh = new THREE.Mesh(geometry, material);\n        this.mesh.add(centerMesh);\n\n        this.hitbox = new PolyHitbox(this.mesh, geometry);\n    }\n\n    update = () => {\n        const elapsed = this.clock.getElapsed();\n\n        const scale = linearMap(Math.sin(elapsed * 10), -1, 1, 0.99, 1.01);\n\n        this.mesh.scale.set(scale, scale, scale);\n    };\n}\n","import { MathUtils } from '../utils/utils';\n\n// All posible inputs\nexport enum Movements {\n    up = 'up',\n    down = 'down',\n    left = 'left',\n    right = 'right',\n    forwards = 'forwards',\n    backwards = 'backwards',\n    rollLeft = 'rollLeft',\n    rollRight = 'rollRight',\n    shoot = 'shoot',\n}\n\n/**\n * for each possible movement we have a number in [0, 1] instead of a boolean\n * so we can support analog input\n */\nexport type MoveState = Record<Movements, number>;\n\nexport const getIdleMoveState = (): MoveState => ({\n    [Movements.up]: 0,\n    [Movements.down]: 0,\n    [Movements.left]: 0,\n    [Movements.right]: 0,\n    [Movements.forwards]: 0,\n    [Movements.backwards]: 0,\n    [Movements.rollLeft]: 0,\n    [Movements.rollRight]: 0,\n    [Movements.shoot]: 0,\n});\n\nexport const lerpMoveStates = (\n    moveState1: MoveState,\n    moveState2: MoveState,\n    factor: number\n): MoveState => ({\n    [Movements.up]: MathUtils.lerp(moveState1[Movements.up], moveState2[Movements.up], factor),\n    [Movements.down]: MathUtils.lerp(\n        moveState1[Movements.down],\n        moveState2[Movements.down],\n        factor\n    ),\n    [Movements.left]: MathUtils.lerp(\n        moveState1[Movements.left],\n        moveState2[Movements.left],\n        factor\n    ),\n    [Movements.right]: MathUtils.lerp(\n        moveState1[Movements.right],\n        moveState2[Movements.right],\n        factor\n    ),\n    [Movements.forwards]: MathUtils.lerp(\n        moveState1[Movements.forwards],\n        moveState2[Movements.forwards],\n        factor\n    ),\n    [Movements.backwards]: MathUtils.lerp(\n        moveState1[Movements.backwards],\n        moveState2[Movements.backwards],\n        factor\n    ),\n    [Movements.rollLeft]: MathUtils.lerp(\n        moveState1[Movements.rollLeft],\n        moveState2[Movements.rollLeft],\n        factor\n    ),\n    [Movements.rollRight]: MathUtils.lerp(\n        moveState1[Movements.rollRight],\n        moveState2[Movements.rollRight],\n        factor\n    ),\n    [Movements.shoot]: moveState2[Movements.shoot],\n});\n\n// All controls must expost a move state\nexport interface PolyControls {\n    moveState: MoveState;\n}\n","import { isNil } from '../utils/utils';\nimport { Movements, MoveState, getIdleMoveState, PolyControls } from './polyControls';\n\n/**\n * PolyControls.\n *\n * This module takes care of binding keys to movements\n * and exposing an object that represents the current input\n * abstracted away from the actual keys that are being pressed\n */\n\n// Map movements to key 'code'\nexport type KeyMapping = Map<string, Movements>;\n\n// Default key binding\nexport const getDefaultKeyMapping = (): KeyMapping => {\n    const keyMapping = new Map();\n    keyMapping.set('KeyW', Movements.up);\n    keyMapping.set('KeyS', Movements.down);\n    keyMapping.set('KeyA', Movements.left);\n    keyMapping.set('KeyD', Movements.right);\n    keyMapping.set('KeyI', Movements.forwards);\n    keyMapping.set('KeyK', Movements.backwards);\n    keyMapping.set('KeyJ', Movements.rollLeft);\n    keyMapping.set('KeyL', Movements.rollRight);\n    keyMapping.set('Space', Movements.shoot);\n\n    return keyMapping;\n};\n\nexport class KeyboardControls implements PolyControls {\n    public moveState: MoveState;\n    private keyMapping: KeyMapping;\n\n    constructor() {\n        this.moveState = getIdleMoveState();\n        this.keyMapping = getDefaultKeyMapping();\n    }\n\n    // When binding a key reset the moveState to avoid locking buttons.\n    public bindKey = (key: string, movement: Movements): void => {\n        this.keyMapping.set(key, movement);\n        this.moveState = getIdleMoveState();\n    };\n\n    public attachListeners = (): void => {\n        window.addEventListener('keydown', this.keyDownHandler);\n        window.addEventListener('keyup', this.keyUpHandler);\n    };\n\n    public dispose = (): void => {\n        window.addEventListener('keydown', this.keyDownHandler);\n        window.addEventListener('keyup', this.keyUpHandler);\n    };\n\n    private keyDownHandler = (e: KeyboardEvent): void => {\n        const movement = this.keyMapping.get(e.code);\n\n        if (isNil(movement)) {\n            return;\n        }\n\n        this.moveState[movement] = 1;\n    };\n\n    private keyUpHandler = (e: KeyboardEvent): void => {\n        const movement = this.keyMapping.get(e.code);\n\n        if (isNil(movement)) {\n            return;\n        }\n\n        this.moveState[movement] = 0;\n    };\n}\n","import * as THREE from 'three';\n\n/**\n * The delta and elapsed must be recomputed with `tick` on every render\n */\nexport interface ClockTick {\n    delta: number;\n    elapsed: number;\n}\n\nexport class PolyClock {\n    private clock: THREE.Clock;\n    private delta: number;\n    private elapsed: number;\n\n    constructor() {\n        // Autostarts\n        this.clock = new THREE.Clock();\n        this.delta = 0;\n        this.elapsed = 0;\n    }\n\n    public getDelta = (): number => {\n        return this.delta;\n    };\n\n    public getElapsed = (): number => {\n        return this.elapsed;\n    };\n\n    public tick = (): void => {\n        this.delta = this.clock.getDelta();\n        this.elapsed = this.clock.getElapsedTime();\n    };\n}\n","import * as THREE from 'three';\nimport {\n    PolyControls,\n    Movements,\n    MoveState,\n    getIdleMoveState,\n    lerpMoveStates,\n} from './polyControls';\nimport { MAX_RADIUS, MIN_RADIUS } from '../constants';\nimport { ShotManager } from '../objects/shots/manager';\nimport { PolyClock } from '../clock/PolyClock';\n\n/**\n * Transforms an object based on the supplied controls\n */\nconst MOVEMENT_EPSILON = 0.00001;\n\nexport class ObjectController {\n    private moveState: MoveState;\n    private shotDelta: number;\n\n    private orbitSpeed: number;\n    private rollSpeed: number;\n    private forwardsAndBackwardsSpeed: number;\n    private inertiaFactor: number;\n    private shotRecoveryTime: number;\n\n    constructor(\n        private controls: PolyControls,\n        private object: THREE.Object3D,\n        private shots: ShotManager,\n        private clock: PolyClock\n    ) {\n        this.moveState = getIdleMoveState();\n        this.shotDelta = 0;\n\n        this.orbitSpeed = 0.05;\n        this.rollSpeed = 0.05;\n        this.forwardsAndBackwardsSpeed = 0.5;\n        this.inertiaFactor = 0.1;\n        this.shotRecoveryTime = 0.15;\n\n        this.update();\n    }\n\n    // TODO: Make movement (and probably followCamera) frame independent\n    // See https://github.com/ivoelbert/poly-remake/ssues/2\n    public update = (): void => {\n        // Movement inertia\n        this.moveState = lerpMoveStates(\n            this.moveState,\n            this.controls.moveState,\n            this.inertiaFactor\n        );\n\n        this.updateDepth();\n        this.updateOrbit();\n        this.updateShots();\n    };\n\n    private updateDepth = (): void => {\n        const depthMovement =\n            this.moveState[Movements.backwards] - this.moveState[Movements.forwards];\n        if (Math.abs(depthMovement) > MOVEMENT_EPSILON) {\n            const zOffset = depthMovement * this.forwardsAndBackwardsSpeed;\n\n            let objectRadius = this.object.position.length();\n\n            if (objectRadius + zOffset < MIN_RADIUS) {\n                objectRadius = MIN_RADIUS;\n            } else if (objectRadius + zOffset > MAX_RADIUS) {\n                objectRadius = MAX_RADIUS;\n            } else {\n                objectRadius += zOffset;\n            }\n\n            this.object.position.setLength(objectRadius);\n        }\n    };\n\n    private updateOrbit = (): void => {\n        const xAxis = new THREE.Vector3();\n        const yAxis = new THREE.Vector3();\n        const zAxis = new THREE.Vector3();\n        this.object.matrix.extractBasis(xAxis, yAxis, zAxis);\n\n        const verticalOrbit = this.moveState[Movements.up] - this.moveState[Movements.down];\n        const horizontalOrbit = this.moveState[Movements.right] - this.moveState[Movements.left];\n\n        const verticalVector = xAxis.clone();\n        verticalVector.multiplyScalar(verticalOrbit);\n        const horizontalVector = yAxis.clone();\n        horizontalVector.multiplyScalar(horizontalOrbit);\n\n        const directionVector = new THREE.Vector3()\n            .addVectors(verticalVector, horizontalVector)\n            .clampLength(0, 1);\n        const rotationAngle = directionVector.length();\n\n        if (rotationAngle > MOVEMENT_EPSILON) {\n            directionVector.normalize();\n            this.object.position.applyAxisAngle(directionVector, rotationAngle * this.orbitSpeed);\n        }\n\n        const roll = this.moveState[Movements.rollRight] - this.moveState[Movements.rollLeft];\n        yAxis.applyAxisAngle(zAxis, roll * this.rollSpeed);\n        this.object.up.copy(yAxis);\n        this.object.lookAt(0, 0, 0);\n    };\n\n    private updateShots = (): void => {\n        this.shotDelta += this.clock.getDelta();\n\n        if (this.shotDelta > this.shotRecoveryTime && this.moveState[Movements.shoot] === 1) {\n            this.shotDelta = 0;\n            this.shots.spawn(this.object.position);\n        }\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { MAX_RADIUS } from '../../constants';\nimport { PolyHitbox } from '../hitbox';\n\nexport class PolyShip implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    constructor() {\n        const geometry = this.createGeometry();\n\n        const material = new THREE.MeshBasicMaterial({\n            color: 0xfafafa,\n            wireframe: true,\n        });\n\n        this.mesh = new THREE.Mesh(geometry, material);\n        this.mesh.position.set(0, 0, MAX_RADIUS);\n\n        this.hitbox = new PolyHitbox(this.mesh, geometry);\n    }\n\n    public update = () => {\n        this.hitbox.update();\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        console.log('OH SHIT!');\n    };\n\n    private createGeometry = (): THREE.BufferGeometry => {\n        const geometry = new THREE.BufferGeometry();\n\n        const frontPoint = [0, 0, 1];\n        const backTop = [0, 0.25, 0];\n        const backLeft = [-0.5, -0.25, 0];\n        const backRight = [0.5, -0.25, 0];\n\n        const vertices = new Float32Array([\n            ...frontPoint,\n            ...backTop,\n            ...backLeft,\n\n            ...frontPoint,\n            ...backTop,\n            ...backRight,\n\n            ...frontPoint,\n            ...backLeft,\n            ...backRight,\n\n            ...backTop,\n            ...backLeft,\n            ...backRight,\n        ]);\n\n        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n\n        return geometry;\n    };\n}\n","import * as THREE from 'three';\n\nexport class FollowCamera extends THREE.PerspectiveCamera {\n    private distance: number;\n    private inertiaFactor: number;\n\n    constructor(private followedObject: THREE.Object3D) {\n        super(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n\n        this.distance = 2;\n        this.inertiaFactor = 0.8;\n\n        this.update();\n    }\n\n    // TODO: Make movement (and probably followCamera) frame independent\n    // See https://github.com/ivoelbert/poly-remake/issues/2\n    update = (): void => {\n        const followedPosition = this.followedObject.position.clone();\n        followedPosition.add(followedPosition.clone().normalize().multiplyScalar(this.distance));\n\n        const newPosition = new THREE.Vector3().lerpVectors(\n            this.position,\n            followedPosition,\n            this.inertiaFactor\n        );\n\n        this.position.copy(newPosition);\n        this.up.copy(this.followedObject.up);\n        this.lookAt(0, 0, 0);\n    };\n}\n","import * as THREE from 'three';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\n\nconst BLOOM_PARAMS = {\n    exposure: 1.01,\n    bloomStrength: 1.1,\n    bloomThreshold: 0,\n    bloomRadius: 0,\n};\n\nexport class PolyRenderer {\n    private renderer: THREE.WebGLRenderer;\n    private composer: EffectComposer;\n\n    constructor(scene: THREE.Scene, camera: THREE.Camera) {\n        this.renderer = new THREE.WebGLRenderer();\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.renderer.toneMappingExposure = Math.pow(BLOOM_PARAMS.exposure, 4.0);\n        this.renderer.outputEncoding = THREE.sRGBEncoding;\n\n        const renderScene = new RenderPass(scene, camera);\n\n        const bloomPass = new UnrealBloomPass(\n            new THREE.Vector2(window.innerWidth, window.innerHeight),\n            BLOOM_PARAMS.bloomStrength,\n            BLOOM_PARAMS.bloomRadius,\n            BLOOM_PARAMS.bloomThreshold\n        );\n\n        this.composer = new EffectComposer(this.renderer);\n        this.composer.renderToScreen = false;\n        this.composer.addPass(renderScene);\n        this.composer.addPass(bloomPass);\n\n        this.composer.renderToScreen = true;\n    }\n\n    public getDomElement = (): HTMLCanvasElement => {\n        return this.renderer.domElement;\n    };\n\n    public resize = (): void => {\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.composer.setSize(window.innerWidth, window.innerHeight);\n    };\n\n    public render = (): void => {\n        this.composer.render();\n    };\n}\n","import * as THREE from 'three';\n\nexport class PolyScene {\n    public readonly scene: THREE.Scene;\n\n    constructor() {\n        this.scene = new THREE.Scene();\n        this.scene.fog = new THREE.FogExp2(0x000000, 0.000025);\n\n        const light = new THREE.AmbientLight(0xffffff);\n        this.scene.add(light);\n    }\n\n    public add = (...objects: THREE.Object3D[]) => this.scene.add(...objects);\n\n    public remove = (...objects: THREE.Object3D[]) => this.scene.remove(...objects);\n\n    public dispose = () => {\n        this.scene.dispose();\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { DropFunction } from '../manager';\nimport { PolyHitbox } from '../hitbox';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { constrain01, easeOutElastic, linearMap } from '../../utils/easing';\nimport { MAX_RADIUS } from '../../constants';\nimport { ExplosionsManager } from '../explosion/manager';\nimport { AsteroidMeshFactory } from './meshFactory';\n\nconst SPAWN_ANIMATION_TIME = 1;\n\nexport class Asteroid implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    private normal: THREE.Vector3;\n    private angularVelocity: number;\n    private radialVelocity: number;\n\n    private epoch: number;\n\n    constructor(\n        meshFactory: AsteroidMeshFactory,\n        private clock: PolyClock,\n        private explosions: ExplosionsManager,\n        private dropObject: DropFunction<Asteroid>\n    ) {\n        this.mesh = meshFactory.buildMesh();\n        this.hitbox = new PolyHitbox(this.mesh, meshFactory.getHitboxGeometry());\n\n        this.normal = new THREE.Vector3(0, 1, 0);\n\n        this.angularVelocity = 1;\n        this.radialVelocity = 1;\n        this.epoch = 0;\n    }\n\n    public spawn = (position: THREE.Vector3, normal: THREE.Vector3): void => {\n        this.mesh.position.copy(position);\n        this.normal = normal;\n        this.epoch = this.clock.getElapsed();\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        this.drop();\n    };\n\n    public update = (): void => {\n        const delta = this.clock.getDelta();\n        const elapsed = this.clock.getElapsed();\n\n        const lifeTime = elapsed - this.epoch;\n        const timeFactor = constrain01(linearMap(lifeTime, 0, SPAWN_ANIMATION_TIME, 0, 1));\n        const easedTimeFactor = easeOutElastic(timeFactor);\n\n        this.mesh.scale.set(easedTimeFactor, easedTimeFactor, easedTimeFactor);\n\n        // Rotation\n        const angleToRotate = this.angularVelocity * delta;\n        this.mesh.position.applyAxisAngle(this.normal, angleToRotate);\n\n        // radial movement\n        const currentLength = this.mesh.position.length();\n        const lengthOffset = this.radialVelocity * delta;\n        this.mesh.position.setLength(currentLength + lengthOffset);\n\n        this.hitbox.update();\n\n        if (tooFarFromCenter(this.mesh.position)) {\n            this.drop();\n        }\n    };\n\n    private drop = () => {\n        this.explosions.spawn(this.mesh.position.clone());\n        this.dropObject(this);\n    };\n}\n\nfunction tooFarFromCenter(point: THREE.Vector3): boolean {\n    return point.length() > MAX_RADIUS;\n}\n","import * as THREE from 'three';\n\nexport class AsteroidMeshFactory {\n    private mesh: THREE.Mesh;\n    private hitboxGeometry: THREE.Geometry | THREE.BufferGeometry;\n\n    constructor() {\n        this.hitboxGeometry = new THREE.DodecahedronBufferGeometry(1.5);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0x2bfa2b,\n            wireframe: true,\n        });\n\n        this.mesh = new THREE.Mesh(this.hitboxGeometry, material);\n    }\n\n    public buildMesh = (): THREE.Mesh => {\n        return this.mesh.clone();\n    };\n\n    public getHitboxGeometry = (): THREE.Geometry | THREE.BufferGeometry => {\n        return this.hitboxGeometry.clone();\n    };\n}\n","import { PolyObject } from './objects/polyObject';\n\nexport enum Groups {\n    asteroids,\n    ship,\n    shots,\n    missiles,\n    center,\n}\n\ninterface Collider {\n    addRule: (g1: Groups, g2: Groups) => void;\n    addObjectToGroup: (obj: PolyObject, group: Groups) => void;\n    removeObjectFromGroup: (obj: PolyObject, group: Groups) => void;\n    update: () => void;\n}\n\ntype ColliderGroups = Record<Groups, Set<PolyObject>>;\n\nexport class PolyCollider implements Collider {\n    private rules: Set<[Groups, Groups]>;\n    private groups: ColliderGroups;\n\n    constructor() {\n        this.rules = new Set();\n        this.groups = {\n            [Groups.asteroids]: new Set(),\n            [Groups.ship]: new Set(),\n            [Groups.shots]: new Set(),\n            [Groups.missiles]: new Set(),\n            [Groups.center]: new Set(),\n        };\n    }\n\n    addRule = (g1: Groups, g2: Groups): void => {\n        this.rules.add([g1, g2]);\n    };\n\n    addObjectToGroup = (obj: PolyObject, group: Groups): void => {\n        this.groups[group].add(obj);\n    };\n\n    removeObjectFromGroup = (obj: PolyObject, group: Groups): void => {\n        this.groups[group].delete(obj);\n    };\n\n    update = (): void => {\n        this.rules.forEach(([g1, g2]) => {\n            this.groups[g1].forEach((o1) => {\n                this.groups[g2].forEach((o2) => {\n                    if (polyObjectsCollide(o1, o2)) {\n                        o1.onCollide?.(o2);\n                        o2.onCollide?.(o1);\n                    }\n                });\n            });\n        });\n    };\n}\n\nconst polyObjectsCollide = (o1: PolyObject, o2: PolyObject): boolean => {\n    return o1.hitbox.intersects(o2.hitbox);\n};\n","import { Vector3 } from 'three';\nimport { Asteroid } from './asteroid';\nimport { PolyScene } from '../../scene/PolyScene';\nimport {\n    repeat,\n    getDumpster,\n    randomUnitVector,\n    assertExists,\n    getOne,\n    randomOrthogonalUnitVector,\n} from '../../utils/utils';\nimport { ASTEROIDS_IN_SCENE, CENTER_RADIUS } from '../../constants';\nimport { Manager } from '../manager';\nimport { AsteroidMeshFactory } from './meshFactory';\nimport { PolyCollider, Groups } from '../../collider';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ExplosionsManager } from '../explosion/manager';\n\nexport class AsteroidManager implements Manager<Asteroid> {\n    private idleObjects: Set<Asteroid>;\n    private liveObjects: Set<Asteroid>;\n    private intervalId: NodeJS.Timeout | null;\n\n    constructor(\n        private scene: PolyScene,\n        private collider: PolyCollider,\n        private clock: PolyClock,\n        private explosions: ExplosionsManager\n    ) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n\n        const meshFactory = new AsteroidMeshFactory();\n        repeat(ASTEROIDS_IN_SCENE, (_) => {\n            const object = new Asteroid(meshFactory, this.clock, this.explosions, this.drop);\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n        this.intervalId = null;\n    }\n\n    public start = () => {\n        this.intervalId = setInterval(this.spawnRandom, 3000);\n    };\n\n    public spawn = (position: Vector3, normal: Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position, normal);\n\n        this.collider.addObjectToGroup(objectToSpawn, Groups.asteroids);\n    };\n\n    public drop = (objectToDelete: Asteroid) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n\n        this.collider.removeObjectFromGroup(objectToDelete, Groups.asteroids);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n\n        if (this.intervalId !== null) {\n            clearTimeout(this.intervalId);\n        }\n    };\n\n    private spawnRandom = (): void => {\n        const normal = randomUnitVector();\n        const position = randomOrthogonalUnitVector(normal).setLength(CENTER_RADIUS);\n\n        this.spawn(position, normal);\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { randomUnitVector, MathUtils } from '../../utils/utils';\nimport { MissileMeshFactory } from './meshFactory';\nimport { DropFunction } from '../manager';\nimport { PolyHitbox } from '../hitbox';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ExplosionsManager } from '../explosion/manager';\n\nconst MISSILE_LIFETIME = 7;\n\nexport class FollowMissile implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    private direction: THREE.Vector3;\n    private angSpeed: number;\n    private speed: number;\n\n    private epoch: number;\n\n    constructor(\n        private object: THREE.Object3D,\n        private clock: PolyClock,\n        private explosions: ExplosionsManager,\n        meshFactory: MissileMeshFactory,\n        private dropObject: DropFunction<FollowMissile>\n    ) {\n        this.angSpeed = 3;\n        this.speed = 40;\n\n        this.mesh = meshFactory.buildMesh();\n        this.direction = randomUnitVector();\n\n        this.hitbox = new PolyHitbox(this.mesh, meshFactory.getHitboxGeometry());\n        this.epoch = 0;\n    }\n\n    public spawn = (position: THREE.Vector3, direction: THREE.Vector3): void => {\n        this.epoch = this.clock.getElapsed();\n        this.mesh.position.copy(position);\n        this.direction.copy(direction);\n        this.direction.normalize();\n\n        this.align();\n    };\n\n    public update = (): void => {\n        this.updateRotation();\n        this.updatePosition();\n        this.updateFlames();\n\n        this.hitbox.update();\n\n        const elapsed = this.clock.getElapsed();\n        const lifeTime = elapsed - this.epoch;\n\n        if (lifeTime > MISSILE_LIFETIME) {\n            this.drop();\n        }\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        this.drop();\n    };\n\n    private updateRotation = (): void => {\n        const delta = this.clock.getDelta();\n        const towards = this.object.position.clone();\n        towards.sub(this.mesh.position);\n\n        const angle = this.direction.angleTo(towards);\n        const clampedAngle = MathUtils.clamp(angle, -this.angSpeed * delta, this.angSpeed * delta);\n\n        const normal = new THREE.Vector3().crossVectors(towards, this.direction);\n        normal.normalize();\n\n        this.direction.applyAxisAngle(normal, -clampedAngle);\n        this.align();\n    };\n\n    private updatePosition = (): void => {\n        const delta = this.clock.getDelta();\n        const step = this.direction.clone();\n        step.multiplyScalar(this.speed * delta);\n\n        this.mesh.position.add(step);\n    };\n\n    private updateFlames = (): void => {\n        const delta = this.clock.getDelta();\n        const elapsed = this.clock.getElapsed();\n        this.mesh.children[0].scale.y += Math.sin(elapsed * 10) * 0.05;\n        this.mesh.children[0].rotateY(delta * 10);\n        this.mesh.children[1].scale.y -= Math.cos(elapsed * 10) * 0.05;\n        this.mesh.children[1].rotateY(delta * 10);\n    };\n\n    private align = (): void => {\n        const lookAtPos = this.mesh.position.clone();\n        lookAtPos.add(this.direction);\n        this.mesh.lookAt(lookAtPos);\n        this.mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI * 0.5);\n    };\n\n    private drop = () => {\n        this.explosions.spawn(this.mesh.position.clone());\n        this.dropObject(this);\n    };\n}\n","import * as THREE from 'three';\n\nexport class MissileMeshFactory {\n    private mesh: THREE.Mesh;\n    private hitboxGeometry: THREE.Geometry | THREE.BufferGeometry;\n\n    constructor() {\n        this.hitboxGeometry = new THREE.CylinderBufferGeometry(0.2, 0.4, 1, 6, 1);\n        const misilMaterial = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0xffffff,\n        });\n\n        const fireGeom = new THREE.ConeBufferGeometry(0.3, 1, 6);\n\n        const lightFireMat = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0xeeec74,\n        });\n\n        const darkFireMat = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0xee5137,\n        });\n\n        const lightFire = new THREE.Mesh(fireGeom, lightFireMat);\n        const darkFire = new THREE.Mesh(fireGeom, darkFireMat);\n        lightFire.position.y -= 1;\n        darkFire.position.y -= 1;\n        lightFire.rotateX(Math.PI);\n        darkFire.rotateX(Math.PI);\n\n        this.mesh = new THREE.Mesh(this.hitboxGeometry, misilMaterial);\n        this.mesh.add(lightFire);\n        this.mesh.add(darkFire);\n    }\n\n    public buildMesh = (): THREE.Mesh => {\n        return this.mesh.clone();\n    };\n\n    public getHitboxGeometry = (): THREE.Geometry | THREE.BufferGeometry => {\n        return this.hitboxGeometry.clone();\n    };\n}\n","import { Vector3 } from 'three';\nimport { FollowMissile } from './followMissile';\nimport { PolyScene } from '../../scene/PolyScene';\nimport {\n    repeat,\n    getDumpster,\n    getOne,\n    assertExists,\n    randomUnitVector,\n    getOrigin,\n} from '../../utils/utils';\nimport { MISSILES_IN_SCENE } from '../../constants';\nimport { Manager } from '../manager';\nimport { MissileMeshFactory } from './meshFactory';\nimport { PolyCollider, Groups } from '../../collider';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ExplosionsManager } from '../explosion/manager';\n\nexport class FollowMissileManager implements Manager<FollowMissile> {\n    private idleObjects: Set<FollowMissile>;\n    private liveObjects: Set<FollowMissile>;\n    private intervalId: NodeJS.Timeout | null;\n\n    constructor(\n        private scene: PolyScene,\n        followedObject: THREE.Object3D,\n        private clock: PolyClock,\n        private collider: PolyCollider,\n        explosions: ExplosionsManager\n    ) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n        const meshFactory = new MissileMeshFactory();\n\n        repeat(MISSILES_IN_SCENE, (_) => {\n            const object = new FollowMissile(\n                followedObject,\n                this.clock,\n                explosions,\n                meshFactory,\n                this.drop\n            );\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n        this.intervalId = null;\n    }\n\n    public start = () => {\n        const initialPosition = getOrigin();\n        this.spawn(initialPosition, randomUnitVector());\n        this.intervalId = setInterval(() => this.spawn(initialPosition, randomUnitVector()), 10000);\n    };\n\n    public spawn = (position: Vector3, direction: Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position, direction);\n\n        this.collider.addObjectToGroup(objectToSpawn, Groups.missiles);\n    };\n\n    public drop = (objectToDelete: FollowMissile) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n\n        this.collider.removeObjectFromGroup(objectToDelete, Groups.missiles);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n\n        if (this.intervalId !== null) {\n            clearInterval(this.intervalId);\n        }\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { DropFunction } from '../manager';\nimport { CENTER_RADIUS } from '../../constants';\nimport { PolyHitbox } from '../hitbox';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ShotMeshFactory } from './meshFactory';\n\nexport class Shot implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    private speed: number;\n\n    constructor(\n        meshFactory: ShotMeshFactory,\n        private clock: PolyClock,\n        private dropObject: DropFunction<Shot>\n    ) {\n        this.mesh = meshFactory.buildMesh();\n        this.hitbox = new PolyHitbox(this.mesh, meshFactory.getHitboxGeometry());\n\n        this.speed = 200;\n    }\n\n    public spawn = (position: THREE.Vector3): void => {\n        this.mesh.position.copy(position);\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        this.drop();\n    };\n\n    public update = (): void => {\n        const delta = this.clock.getDelta();\n\n        const currentLength = this.mesh.position.length();\n        const lengthOffset = this.speed * delta;\n        this.mesh.position.setLength(currentLength - lengthOffset);\n\n        this.hitbox.update();\n\n        if (this.mesh.position.length() <= CENTER_RADIUS) {\n            this.drop();\n        }\n    };\n\n    private drop = () => {\n        this.dropObject(this);\n    };\n}\n","import * as THREE from 'three';\n\nexport class ShotMeshFactory {\n    private mesh: THREE.Mesh;\n    private hitboxGeometry: THREE.Geometry | THREE.BufferGeometry;\n\n    constructor() {\n        const coreGeometry = new THREE.DodecahedronBufferGeometry(0.15);\n        const coreMaterial = new THREE.MeshBasicMaterial({\n            color: 0xfff36e,\n            wireframe: true,\n        });\n\n        const coreMesh = new THREE.Mesh(coreGeometry, coreMaterial);\n\n        this.hitboxGeometry = new THREE.DodecahedronBufferGeometry(0.3);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0xd68400,\n            wireframe: true,\n        });\n\n        this.mesh = new THREE.Mesh(this.hitboxGeometry, material);\n        this.mesh.add(coreMesh);\n    }\n\n    public buildMesh = (): THREE.Mesh => {\n        return this.mesh.clone();\n    };\n\n    public getHitboxGeometry = (): THREE.Geometry | THREE.BufferGeometry => {\n        return this.hitboxGeometry.clone();\n    };\n}\n","import * as THREE from 'three';\nimport { Shot } from './shot';\nimport { PolyScene } from '../../scene/PolyScene';\nimport { repeat, getDumpster, getOne, assertExists } from '../../utils/utils';\nimport { SHOTS_IN_SCENE } from '../../constants';\nimport { Manager } from '../manager';\nimport { ShotMeshFactory } from './meshFactory';\nimport { PolyCollider, Groups } from '../../collider';\nimport { PolyClock } from '../../clock/PolyClock';\n\nexport class ShotManager implements Manager<Shot> {\n    private idleObjects: Set<Shot>;\n    private liveObjects: Set<Shot>;\n\n    constructor(\n        private scene: PolyScene,\n        private collider: PolyCollider,\n        private clock: PolyClock\n    ) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n\n        const meshFactory = new ShotMeshFactory();\n        repeat(SHOTS_IN_SCENE, (_) => {\n            const object = new Shot(meshFactory, this.clock, this.drop);\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n    }\n\n    public spawn = (position: THREE.Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position);\n\n        this.collider.addObjectToGroup(objectToSpawn, Groups.shots);\n    };\n\n    public drop = (objectToDelete: Shot) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n\n        this.collider.removeObjectFromGroup(objectToDelete, Groups.shots);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n    };\n}\n","import * as THREE from 'three';\nimport { CENTER_RADIUS } from '../../constants';\nimport { randFloat, randomUnitVector } from '../../utils/utils';\n\nexport const FRAGMENT_INITIAL_COLOR = new THREE.Color(0xffff96);\nexport const FRAGMENT_END_COLOR = new THREE.Color(0x610200);\n\nexport class ExplosionMeshFactory {\n    public buildMesh = (): THREE.Mesh => {\n        const fragmentMaterial = new THREE.MeshBasicMaterial({\n            color: FRAGMENT_INITIAL_COLOR,\n            wireframe: true,\n            transparent: true,\n        });\n\n        const groupMesh = new THREE.Mesh();\n\n        const initialPositions = new THREE.SphereGeometry(0.1, 6, 6).vertices;\n\n        initialPositions.forEach((initialPosition) => {\n            const fragmentSize = randFloat(CENTER_RADIUS * 0.05, CENTER_RADIUS * 0.2);\n            const fragmentGeometry = new THREE.TetrahedronBufferGeometry(fragmentSize);\n\n            const fragmentMesh = new THREE.Mesh(fragmentGeometry, fragmentMaterial);\n            fragmentMesh.position.copy(initialPosition);\n\n            groupMesh.add(fragmentMesh);\n        });\n\n        const rotationAngle = randFloat(0, 2 * Math.PI);\n        groupMesh.rotateOnAxis(randomUnitVector(), rotationAngle);\n        return groupMesh;\n    };\n}\n","import * as THREE from 'three';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { CENTER_RADIUS } from '../../constants';\nimport { constrain01, linearMap } from '../../utils/easing';\nimport { noop, randFloat } from '../../utils/utils';\nimport { Hitbox, NoCollisionsHitbox } from '../hitbox';\nimport { DropFunction } from '../manager';\nimport { PolyObject } from '../polyObject';\nimport { ExplosionMeshFactory, FRAGMENT_END_COLOR, FRAGMENT_INITIAL_COLOR } from './meshFactory';\n\nconst FRAGMENT_LIFETIME = 1;\n\nexport class Explosion implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: Hitbox;\n\n    private epoch: number;\n    private fragmentSpeeds: number[];\n\n    constructor(\n        meshFactory: ExplosionMeshFactory,\n        private clock: PolyClock,\n        private dropObject: DropFunction<Explosion>\n    ) {\n        this.mesh = meshFactory.buildMesh();\n        this.hitbox = new NoCollisionsHitbox();\n\n        this.epoch = 0;\n        this.fragmentSpeeds = this.getRandomSpeeds();\n    }\n\n    public spawn = (position: THREE.Vector3): void => {\n        this.mesh.position.copy(position);\n        this.epoch = this.clock.getElapsed();\n        this.fragmentSpeeds = this.getRandomSpeeds();\n        this.mesh.children.forEach((fragmentObject) => {\n            fragmentObject.position.setLength(0.1);\n        });\n    };\n\n    public onCollide = noop;\n\n    public update = (): void => {\n        const elapsed = this.clock.getElapsed();\n        const delta = this.clock.getDelta();\n        const lifeTime = elapsed - this.epoch;\n\n        const opacity = constrain01(linearMap(lifeTime, 0, FRAGMENT_LIFETIME, 1, 0));\n\n        const colorFactor = constrain01(linearMap(lifeTime, 0, FRAGMENT_LIFETIME, 0, 1));\n        const color = new THREE.Color(FRAGMENT_INITIAL_COLOR).lerp(FRAGMENT_END_COLOR, colorFactor);\n\n        this.mesh.children.forEach((fragmentObject, idx) => {\n            const speed = this.fragmentSpeeds[idx];\n            const fragment = fragmentObject as THREE.Mesh;\n\n            const dir = fragment.position.clone().setLength(delta * speed);\n            fragment.position.add(dir);\n            (fragment.material as THREE.MeshBasicMaterial).opacity = opacity;\n            (fragment.material as THREE.MeshBasicMaterial).color = color;\n        });\n\n        if (lifeTime > FRAGMENT_LIFETIME) {\n            this.drop();\n        }\n    };\n\n    private getRandomSpeeds = (): number[] => {\n        return this.mesh.children.map((_) => {\n            return randFloat(0.5 * CENTER_RADIUS, 1 * CENTER_RADIUS);\n        });\n    };\n\n    private drop = () => {\n        this.dropObject(this);\n    };\n}\n","import { PolyClock } from '../../clock/PolyClock';\nimport { EXPLOSIONS_IN_SCENE } from '../../constants';\nimport { PolyScene } from '../../scene/PolyScene';\nimport { assertExists, getDumpster, getOne, repeat } from '../../utils/utils';\nimport { Manager } from '../manager';\nimport { Explosion } from './explosion';\nimport { ExplosionMeshFactory } from './meshFactory';\n\nexport class ExplosionsManager implements Manager<Explosion> {\n    private idleObjects: Set<Explosion>;\n    private liveObjects: Set<Explosion>;\n\n    constructor(private scene: PolyScene, private clock: PolyClock) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n\n        const meshFactory = new ExplosionMeshFactory();\n        repeat(EXPLOSIONS_IN_SCENE, (_) => {\n            const object = new Explosion(meshFactory, this.clock, this.drop);\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n    }\n\n    public spawn = (position: THREE.Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position);\n    };\n\n    public drop = (objectToDelete: Explosion) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n    };\n}\n","import { Stars } from './objects/stars/stars';\nimport { consoleInfo } from './utils/utils';\nimport { Center } from './objects/center';\nimport { KeyboardControls } from './controls/keyboardControls';\nimport { PolyClock } from './clock/PolyClock';\nimport { ObjectController } from './controls/objectController';\nimport { PolyShip } from './objects/ship/ship';\nimport { FollowCamera } from './objects/followCamera';\nimport { PolyRenderer } from './renderer';\nimport { PolyScene } from './scene/PolyScene';\nimport { AsteroidManager } from './objects/asteroid/manager';\nimport { FollowMissileManager } from './objects/followMissile/manager';\nimport { ShotManager } from './objects/shots/manager';\nimport { PolyCollider, Groups } from './collider';\nimport { ExplosionsManager } from './objects/explosion/manager';\n\nexport class Polybius {\n    private renderer: PolyRenderer;\n    private clock: PolyClock;\n    private camera: FollowCamera;\n    private controls: KeyboardControls;\n    private objectController: ObjectController;\n    private center: Center;\n    private ship: PolyShip;\n    private scene: PolyScene;\n    private explosions: ExplosionsManager;\n    private asteroids: AsteroidManager;\n    private missiles: FollowMissileManager;\n    private shots: ShotManager;\n    private collider: PolyCollider;\n\n    constructor() {\n        // Set up the scene\n        this.scene = new PolyScene();\n\n        // Set up the clock\n        this.clock = new PolyClock();\n\n        // Set up the collider\n        this.collider = new PolyCollider();\n        this.collider.addRule(Groups.asteroids, Groups.ship);\n        this.collider.addRule(Groups.shots, Groups.asteroids);\n        this.collider.addRule(Groups.shots, Groups.center);\n        this.collider.addRule(Groups.shots, Groups.missiles);\n        this.collider.addRule(Groups.missiles, Groups.ship);\n\n        this.explosions = new ExplosionsManager(this.scene, this.clock);\n\n        // Set up the ship\n        this.ship = new PolyShip();\n        this.collider.addObjectToGroup(this.ship, Groups.ship);\n\n        // Set up camera\n        this.camera = new FollowCamera(this.ship.mesh);\n\n        // Set up the renderer\n        this.renderer = new PolyRenderer(this.scene.scene, this.camera);\n        this.renderer.resize();\n\n        // Set up various objects and managers\n        const stars = new Stars();\n        this.center = new Center(this.clock);\n        this.collider.addObjectToGroup(this.center, Groups.center);\n\n        this.scene.add(this.ship.mesh, stars.mesh, this.center.mesh);\n\n        this.asteroids = new AsteroidManager(\n            this.scene,\n            this.collider,\n            this.clock,\n            this.explosions\n        );\n        this.missiles = new FollowMissileManager(\n            this.scene,\n            this.ship.mesh,\n            this.clock,\n            this.collider,\n            this.explosions\n        );\n        this.shots = new ShotManager(this.scene, this.collider, this.clock);\n\n        this.controls = new KeyboardControls();\n        this.objectController = new ObjectController(\n            this.controls,\n            this.ship.mesh,\n            this.shots,\n            this.clock\n        );\n    }\n\n    public start = (): void => {\n        this.controls.attachListeners();\n        window.addEventListener('resize', this.resize);\n\n        this.asteroids.start();\n        this.missiles.start();\n\n        // Start the render loop!\n        consoleInfo('Game started!');\n        this.animate();\n    };\n\n    public dispose = (): void => {\n        this.controls.dispose();\n        this.asteroids.dispose();\n        this.missiles.dispose();\n        this.explosions.dispose();\n\n        this.scene.dispose();\n        window.removeEventListener('resize', this.resize);\n    };\n\n    public getDomElement = (): HTMLCanvasElement => {\n        return this.renderer.getDomElement();\n    };\n\n    private resize = (): void => {\n        this.renderer.resize();\n        this.camera.aspect = window.innerWidth / window.innerHeight;\n        this.camera.updateProjectionMatrix();\n    };\n\n    // This function represents a frame. It's called once for every frame.\n    private animate = (): void => {\n        requestAnimationFrame(this.animate);\n        this.clock.tick();\n\n        this.objectController.update();\n        this.ship.update();\n        this.center.update();\n\n        this.missiles.update();\n        this.asteroids.update();\n        this.shots.update();\n        this.explosions.update();\n\n        this.collider.update();\n\n        this.camera.update();\n        this.renderer.render();\n    };\n}\n","import { useEffect } from 'react';\nimport { Polybius } from '../game/polybius';\nimport { assertExists } from '../game/utils/utils';\nimport { useLazyRef } from './useLazyRef';\n\ntype CallbackRef = (element: HTMLElement | null) => void;\n\nexport const usePolybius = (): CallbackRef => {\n    const polybius = useLazyRef(() => new Polybius());\n\n    useEffect(() => {\n        polybius.start();\n\n        return () => polybius.dispose();\n    }, [polybius]);\n\n    const callbackRef = (element: HTMLElement | null): void => {\n        assertExists(element).appendChild(polybius.getDomElement());\n    };\n\n    return callbackRef;\n};\n","import { useRef } from 'react';\n\nexport type InitRef<T> = () => T;\n\nexport function useLazyRef<T>(init: InitRef<T>) {\n    const ref = useRef<T | null>(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n\n    return ref.current;\n}\n","import React, { useState } from 'react';\nimport { usePolybius } from './hooks/usePolybius';\nimport './App.scss';\n\nexport function App() {\n    const [isPlaying, setIsPlaying] = useState(false);\n    const startGame = () => {\n        setIsPlaying(true);\n    };\n\n    if (isPlaying) {\n        return <Game />;\n    }\n\n    return <StartScreen startGame={startGame} />;\n}\n\nfunction Game() {\n    const polybiusRef = usePolybius();\n\n    return <div className=\"game-container\" ref={polybiusRef} />;\n}\n\ninterface StartScreenProps {\n    startGame(): void;\n}\n\nfunction StartScreen(props: StartScreenProps) {\n    return (\n        <div className=\"start-screen\">\n            <button onClick={props.startGame}>Start</button>\n        </div>\n    );\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\nimport './index.scss';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}