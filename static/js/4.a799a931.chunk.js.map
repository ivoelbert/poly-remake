{"version":3,"sources":["game/utils/utils.ts","game/constants.ts","game/objects/stars/stars.ts","game/objects/hitbox.ts","game/utils/easing.ts","game/objects/center.ts","game/controls/polyControls.ts","game/controls/keyboardControls.ts","game/clock/PolyClock.ts","game/controls/objectController.ts","game/objects/ship/ship.ts","game/objects/followCamera.ts","game/renderer.ts","game/scene/PolyScene.ts","game/objects/asteroid/asteroid.ts","game/objects/asteroid/meshFactory.ts","game/collider.ts","game/objects/asteroid/manager.ts","game/objects/followMissile/followMissile.ts","game/objects/followMissile/meshFactory.ts","game/objects/followMissile/manager.ts","game/objects/shots/shot.ts","game/objects/shots/meshFactory.ts","game/objects/shots/manager.ts","game/objects/explosion/explosion.ts","game/objects/explosion/meshFactory.ts","game/objects/explosion/manager.ts","game/soundManager.ts","game/clock/scheduler.ts","game/effects.ts","game/polybius.ts","hooks/usePolybius.ts","hooks/useLazyRef.ts","GameComponent.tsx"],"names":["repeat","THREE","times","f","i","MathUtils","randFloat","min","max","Math","random","randomUnitVector","normalize","chance","p","getDumpster","CENTER_RADIUS","isNil","value","undefined","assertExists","msg","UnexpectedNilError","Error","noop","getOne","set","values","next","Stars","mesh","createStarsGeometry","starsGeometry","vertices","distance","push","setAttribute","this","color","size","sizeAttenuation","forEach","material","geometry","stars","matrixAutoUpdate","updateMatrix","add","PolyHitbox","followedObject","shape","hitboxDebug","debug","scene","radius","wireframe","update","objectPosition","position","clone","center","copy","intersects","hitbox","intersectsSphere","internalGeometry","computeBoundingSphere","boundingSphere","NoCollisionsHitbox","linearMap","x","a1","a2","b1","b2","mapLinear","constrain01","lo","hi","constrain","Movements","Center","clock","elapsed","getElapsed","scale","sin","centerMesh","getIdleMoveState","up","down","left","right","forwards","backwards","rollLeft","rollRight","shoot","KeyboardControls","moveState","keyMapping","bindKey","key","movement","attachListeners","window","addEventListener","keyDownHandler","keyUpHandler","dispose","e","get","code","Map","getDefaultKeyMapping","PolyClock","delta","getDelta","tick","getElapsedTime","ObjectController","controls","object","shots","shotDelta","orbitSpeed","rollSpeed","forwardsAndBackwardsSpeed","inertiaFactor","shotRecoveryTime","moveState1","moveState2","factor","lerp","lerpMoveStates","updateDepth","updateOrbit","updateShots","depthMovement","abs","zOffset","objectRadius","length","setLength","xAxis","yAxis","zAxis","matrix","extractBasis","verticalOrbit","horizontalOrbit","verticalVector","multiplyScalar","horizontalVector","directionVector","addVectors","clampLength","rotationAngle","applyAxisAngle","roll","lookAt","spawn","PolyShip","effects","onCollide","who","glitch","createGeometry","frontPoint","backTop","backLeft","backRight","Float32Array","FollowCamera","innerWidth","innerHeight","follow","objectToFollow","followedPosition","newPosition","lerpVectors","PolyRenderer","renderer","getRenderer","getDomElement","domElement","resize","setSize","toneMappingExposure","pow","outputEncoding","isRenderItem","obj","PolyScene","remove","traverse","materials","concat","disposeMaterial","Promise","resolve","then","parent","fog","light","Asteroid","meshFactory","explosions","dropObject","normal","angularVelocity","radialVelocity","epoch","drop","easedTimeFactor","c4","PI","easeOutElastic","angleToRotate","currentLength","lengthOffset","buildMesh","getHitboxGeometry","Groups","AsteroidMeshFactory","hitboxGeometry","PolyCollider","rules","groups","addRule","g1","g2","addObjectToGroup","group","removeObjectFromGroup","delete","o1","o2","polyObjectsCollide","Set","asteroids","ship","missiles","AsteroidManager","collider","idleObjects","liveObjects","intervalId","start","setInterval","spawnRandom","objectToSpawn","objectToDelete","clearTimeout","vec","mostPerpendicular","reduce","best","current","dot","negate","crossVectors","randomOrthogonalUnitVector","_","FollowMissile","direction","angSpeed","speed","align","updateRotation","updatePosition","updateFlames","towards","sub","angle","angleTo","clampedAngle","clamp","step","children","y","rotateY","cos","lookAtPos","rotateOnAxis","MissileMeshFactory","misilMaterial","fireGeom","lightFireMat","darkFireMat","lightFire","darkFire","rotateX","FollowMissileManager","initialPosition","clearInterval","Shot","ShotMeshFactory","coreGeometry","coreMaterial","coreMesh","ShotManager","sounds","playShot","Explosion","explosionMesh","fragmentSpeeds","getRandomSpeeds","traverseFragments","fragment","setRadiusToCenter","lifeTime","idx","extendRadius","materialLifetimeFactor","updateMaterial","speeds","FRAGMENT_INITIAL_COLOR","FRAGMENT_END_COLOR","ExplosionFragmentMesh","setPosition","z","r","amount","dir","fragmentSize","fragmentGeometry","ExplosionMesh","fragments","fragmentMaterial","cb","lifetimeFactor","opacity","buildFragments","initialPositions","getAttribute","count","getX","getY","getZ","transparent","ExplosionMeshFactory","ExplosionsManager","SilentSoundManager","playPickup","Scheduler","after","ms","timeoutId","setTimeout","EffectsManager","camera","composer","renderPass","bloomPass","glitchPass","trigger","w","h","render","RenderPass","PolyBloom","PolyGlitch","EffectComposer","addPass","renderToScreen","BLOOM_PARAMS","UnrealBloomPass","cancelGlitch","enabled","goWild","GlitchPass","Polybius","keyboardControls","objectController","message","console","log","animate","removeEventListener","aspect","updateProjectionMatrix","requestAnimationFrame","usePolybius","polybius","init","ref","useRef","useLazyRef","useEffect","element","appendChild","GameComponent","polybiusRef","className"],"mappings":"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","file":"static/js/4.a799a931.chunk.js","sourcesContent":["import * as THREE from 'three';\nimport { CENTER_RADIUS } from '../constants';\n\ntype RepeatFunction = (index: number) => void;\nexport const repeat = (times: number, f: RepeatFunction) => {\n    for (let i = 0; i < times; i++) {\n        f(i);\n    }\n};\n\nexport const MathUtils = THREE.MathUtils;\n\nexport function randFloat(min: number, max: number) {\n    return Math.random() * (max - min) + min;\n}\n\nexport const randomUnitVector = (): THREE.Vector3 => {\n    return new THREE.Vector3(randFloat(-1, 1), randFloat(-1, 1), randFloat(-1, 1)).normalize();\n};\n\nexport const randomOrthogonalUnitVector = (vec: THREE.Vector3): THREE.Vector3 => {\n    const x = new THREE.Vector3(1, 0, 0);\n    const y = new THREE.Vector3(0, 1, 0);\n    const z = new THREE.Vector3(0, 0, 1);\n\n    const mostPerpendicular = [y, z].reduce((best, current) => {\n        if (vec.dot(best) > vec.dot(current)) {\n            return current;\n        }\n        return best;\n    }, x);\n\n    if (chance(0.5)) {\n        mostPerpendicular.negate();\n    }\n\n    return new THREE.Vector3().crossVectors(vec, mostPerpendicular);\n};\n\nexport const randomTinyVector = (): THREE.Vector3 => {\n    return randomUnitVector().setLength(0.00001);\n};\n\nexport const getOrigin = (): THREE.Vector3 => {\n    return new THREE.Vector3(0, 0, 0);\n};\n\nexport const chance = (p: number): boolean => {\n    return randFloat(0, 1) < p;\n};\n\n// The dumpster has to be very, very far from the center so the camera doesn't catch it.\nconst DUMPSTER_POSITION = CENTER_RADIUS * 1000;\nexport const getDumpster = (): THREE.Vector3 => {\n    return new THREE.Vector3(DUMPSTER_POSITION, DUMPSTER_POSITION, DUMPSTER_POSITION);\n};\n\nexport type nil = undefined | null;\n\nexport const isNil = (value: any): value is nil => {\n    return value === undefined || value === null;\n};\n\nexport const assertExists = <T>(value: T | nil, msg?: string): T => {\n    if (isNil(value)) {\n        throw new UnexpectedNilError(msg);\n    } else {\n        return value;\n    }\n};\n\nexport class UnexpectedNilError extends Error {\n    constructor(msg?: string) {\n        super(msg ?? 'Unexpected nil value!');\n    }\n}\n\nexport const consoleInfo = (message: string): void => {\n    const styles = `\n        background-color: #dadada;\n        color: #2b2bfa;\n        margin: 1em;\n        padding: 0.5em 1em;\n        border-radius: 9999px;\n        font-size: 14px;\n        text-align: center;\n        font-weight: 800;\n    `;\n    console.log(`%c${message}`, styles);\n};\n\nexport const noop = () => {};\n\nexport const getOne = <T>(set: Set<T>): T | nil => {\n    return set.values().next().value;\n};\n\nexport const debug = (info: string): void => {\n    const debugElement = assertExists(document.getElementById('debug-element'));\n    debugElement.style.display = 'block';\n    debugElement.textContent = info;\n};\n\nexport type CancelAction = () => void;\nexport type VoidCallback = () => void;\n","import * as THREE from 'three';\n\nexport const CENTER_RADIUS = 5;\nexport const MIN_RADIUS = 3 * CENTER_RADIUS;\nexport const MAX_RADIUS = 10 * CENTER_RADIUS;\n\nexport const CENTER = new THREE.Vector3();\n\nexport const ASTEROIDS_IN_SCENE = 50;\nexport const MISSILES_IN_SCENE = 50;\nexport const SHOTS_IN_SCENE = 20;\nexport const EXPLOSIONS_IN_SCENE = 50;\n","import * as THREE from 'three';\nimport { repeat, MathUtils } from '../../utils/utils';\nimport { CENTER_RADIUS } from '../../constants';\n\nexport class Stars {\n    public mesh: THREE.Group;\n\n    constructor() {\n        this.mesh = new THREE.Group();\n\n        const starsMaterials = [\n            new THREE.PointsMaterial({\n                color: 0x555555,\n                size: 2,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x555555,\n                size: 1,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x333333,\n                size: 2,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x3a3a3a,\n                size: 1,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x1a1a1a,\n                size: 2,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x1a1a1a,\n                size: 1,\n                sizeAttenuation: false,\n            }),\n        ];\n\n        starsMaterials.forEach((material) => {\n            const geometry = this.createStarsGeometry();\n            const stars = new THREE.Points(geometry, material);\n            stars.matrixAutoUpdate = false;\n            stars.updateMatrix();\n\n            this.mesh.add(stars);\n        });\n    }\n\n    private createStarsGeometry = (): THREE.BufferGeometry => {\n        const starsGeometry = new THREE.BufferGeometry();\n\n        const vertices: number[] = [];\n        repeat(1000, (i: number) => {\n            const distance = MathUtils.randFloat(CENTER_RADIUS * 20, CENTER_RADIUS * 100);\n\n            vertices.push(\n                MathUtils.randFloat(-1, 1) * distance,\n                MathUtils.randFloat(-1, 1) * distance,\n                MathUtils.randFloat(-1, 1) * distance\n            );\n        });\n\n        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n        return starsGeometry;\n    };\n}\n","import * as THREE from 'three';\nimport { assertExists, getDumpster, isNil } from '../utils/utils';\nimport { PolyScene } from '../scene/PolyScene';\n\nexport interface Hitbox {\n    intersects(hitbox: Hitbox): boolean;\n    shape: THREE.Sphere;\n}\n\nexport class PolyHitbox implements Hitbox {\n    readonly shape: THREE.Sphere;\n    private hitboxDebug: THREE.Mesh | null;\n\n    constructor(private followedObject: THREE.Object3D, geometry: THREE.BufferGeometry) {\n        const internalGeometry = geometry.clone();\n        internalGeometry.computeBoundingSphere();\n        this.shape = assertExists(internalGeometry.boundingSphere);\n\n        this.hitboxDebug = null;\n\n        this.update();\n    }\n\n    debug = (scene: PolyScene): void => {\n        const geometry = new THREE.SphereBufferGeometry(this.shape.radius, 8, 6);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0x324ca8,\n            wireframe: true,\n        });\n\n        this.hitboxDebug = new THREE.Mesh(geometry, material);\n\n        scene.add(this.hitboxDebug);\n\n        this.update();\n    };\n\n    update = (): void => {\n        const objectPosition = this.followedObject.position.clone();\n        this.shape.center.copy(objectPosition);\n        if (!isNil(this.hitboxDebug)) {\n            this.hitboxDebug.position.copy(objectPosition);\n        }\n    };\n\n    intersects = (hitbox: Hitbox): boolean => {\n        return this.shape.intersectsSphere(hitbox.shape);\n    };\n}\n\nexport class NoCollisionsHitbox implements Hitbox {\n    readonly shape: THREE.Sphere = new THREE.Sphere(getDumpster(), 0);\n\n    intersects = (hitbox: Hitbox): boolean => {\n        return false;\n    };\n}\n","import * as THREE from 'three';\n\nexport function linearMap(x: number, a1: number, a2: number, b1: number, b2: number): number {\n    return THREE.MathUtils.mapLinear(x, a1, a2, b1, b2);\n}\n\nexport function constrain(x: number, lo: number, hi: number): number {\n    if (x < lo) {\n        return lo;\n    }\n\n    if (x > hi) {\n        return hi;\n    }\n\n    return x;\n}\n\nexport function constrain01(x: number): number {\n    return constrain(x, 0, 1);\n}\n\nexport function easeOutElastic(x: number): number {\n    const c4 = (2 * Math.PI) / 3;\n\n    return x === 0 ? 0 : x === 1 ? 1 : 2 ** (-10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;\n}\n","import * as THREE from 'three';\nimport { PolyObject } from './polyObject';\nimport { CENTER_RADIUS } from '../constants';\nimport { PolyHitbox } from './hitbox';\nimport { PolyClock } from '../clock/PolyClock';\nimport { linearMap } from '../utils/easing';\n\nexport class Center implements PolyObject {\n    public mesh: THREE.Group;\n    public hitbox: PolyHitbox;\n\n    constructor(private clock: PolyClock) {\n        this.mesh = new THREE.Group();\n\n        const geometry = new THREE.SphereBufferGeometry(CENTER_RADIUS, 16, 12);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0xfa2b2b,\n            wireframe: true,\n        });\n\n        const centerMesh = new THREE.Mesh(geometry, material);\n        this.mesh.add(centerMesh);\n\n        this.hitbox = new PolyHitbox(this.mesh, geometry);\n    }\n\n    update = () => {\n        const elapsed = this.clock.getElapsed();\n\n        const scale = linearMap(Math.sin(elapsed * 10), -1, 1, 0.99, 1.01);\n\n        this.mesh.scale.set(scale, scale, scale);\n    };\n}\n","import { MathUtils } from '../utils/utils';\n\n// All posible inputs\nexport enum Movements {\n    up = 'up',\n    down = 'down',\n    left = 'left',\n    right = 'right',\n    forwards = 'forwards',\n    backwards = 'backwards',\n    rollLeft = 'rollLeft',\n    rollRight = 'rollRight',\n    shoot = 'shoot',\n}\n\n/**\n * for each possible movement we have a number in [0, 1] instead of a boolean\n * so we can support analog input\n */\nexport type MoveState = Record<Movements, number>;\n\nexport const getIdleMoveState = (): MoveState => ({\n    [Movements.up]: 0,\n    [Movements.down]: 0,\n    [Movements.left]: 0,\n    [Movements.right]: 0,\n    [Movements.forwards]: 0,\n    [Movements.backwards]: 0,\n    [Movements.rollLeft]: 0,\n    [Movements.rollRight]: 0,\n    [Movements.shoot]: 0,\n});\n\nexport const lerpMoveStates = (\n    moveState1: MoveState,\n    moveState2: MoveState,\n    factor: number\n): MoveState => ({\n    [Movements.up]: MathUtils.lerp(moveState1[Movements.up], moveState2[Movements.up], factor),\n    [Movements.down]: MathUtils.lerp(\n        moveState1[Movements.down],\n        moveState2[Movements.down],\n        factor\n    ),\n    [Movements.left]: MathUtils.lerp(\n        moveState1[Movements.left],\n        moveState2[Movements.left],\n        factor\n    ),\n    [Movements.right]: MathUtils.lerp(\n        moveState1[Movements.right],\n        moveState2[Movements.right],\n        factor\n    ),\n    [Movements.forwards]: MathUtils.lerp(\n        moveState1[Movements.forwards],\n        moveState2[Movements.forwards],\n        factor\n    ),\n    [Movements.backwards]: MathUtils.lerp(\n        moveState1[Movements.backwards],\n        moveState2[Movements.backwards],\n        factor\n    ),\n    [Movements.rollLeft]: MathUtils.lerp(\n        moveState1[Movements.rollLeft],\n        moveState2[Movements.rollLeft],\n        factor\n    ),\n    [Movements.rollRight]: MathUtils.lerp(\n        moveState1[Movements.rollRight],\n        moveState2[Movements.rollRight],\n        factor\n    ),\n    [Movements.shoot]: moveState2[Movements.shoot],\n});\n\n// All controls must expost a move state\nexport interface PolyControls {\n    moveState: MoveState;\n}\n","import { isNil } from '../utils/utils';\nimport { Movements, MoveState, getIdleMoveState, PolyControls } from './polyControls';\n\n/**\n * PolyControls.\n *\n * This module takes care of binding keys to movements\n * and exposing an object that represents the current input\n * abstracted away from the actual keys that are being pressed\n */\n\n// Map movements to key 'code'\nexport type KeyMapping = Map<string, Movements>;\n\n// Default key binding\nexport const getDefaultKeyMapping = (): KeyMapping => {\n    const keyMapping = new Map();\n    keyMapping.set('KeyW', Movements.up);\n    keyMapping.set('KeyS', Movements.down);\n    keyMapping.set('KeyA', Movements.left);\n    keyMapping.set('KeyD', Movements.right);\n    keyMapping.set('KeyI', Movements.forwards);\n    keyMapping.set('KeyK', Movements.backwards);\n    keyMapping.set('KeyJ', Movements.rollLeft);\n    keyMapping.set('KeyL', Movements.rollRight);\n    keyMapping.set('Space', Movements.shoot);\n\n    return keyMapping;\n};\n\nexport class KeyboardControls implements PolyControls {\n    public moveState: MoveState;\n    private keyMapping: KeyMapping;\n\n    constructor() {\n        this.moveState = getIdleMoveState();\n        this.keyMapping = getDefaultKeyMapping();\n    }\n\n    // When binding a key reset the moveState to avoid locking buttons.\n    public bindKey = (key: string, movement: Movements): void => {\n        this.keyMapping.set(key, movement);\n        this.moveState = getIdleMoveState();\n    };\n\n    public attachListeners = (): void => {\n        window.addEventListener('keydown', this.keyDownHandler);\n        window.addEventListener('keyup', this.keyUpHandler);\n    };\n\n    public dispose = (): void => {\n        window.addEventListener('keydown', this.keyDownHandler);\n        window.addEventListener('keyup', this.keyUpHandler);\n    };\n\n    private keyDownHandler = (e: KeyboardEvent): void => {\n        const movement = this.keyMapping.get(e.code);\n\n        if (isNil(movement)) {\n            return;\n        }\n\n        this.moveState[movement] = 1;\n    };\n\n    private keyUpHandler = (e: KeyboardEvent): void => {\n        const movement = this.keyMapping.get(e.code);\n\n        if (isNil(movement)) {\n            return;\n        }\n\n        this.moveState[movement] = 0;\n    };\n}\n","import * as THREE from 'three';\n\n/**\n * The delta and elapsed must be recomputed with `tick` on every render\n */\nexport interface ClockTick {\n    delta: number;\n    elapsed: number;\n}\n\nexport class PolyClock {\n    private clock: THREE.Clock;\n    private delta: number;\n    private elapsed: number;\n\n    constructor() {\n        // Autostarts\n        this.clock = new THREE.Clock();\n        this.delta = 0;\n        this.elapsed = 0;\n    }\n\n    public getDelta = (): number => {\n        return this.delta;\n    };\n\n    public getElapsed = (): number => {\n        return this.elapsed;\n    };\n\n    public tick = (): void => {\n        this.delta = this.clock.getDelta();\n        this.elapsed = this.clock.getElapsedTime();\n    };\n}\n","import * as THREE from 'three';\nimport {\n    PolyControls,\n    Movements,\n    MoveState,\n    getIdleMoveState,\n    lerpMoveStates,\n} from './polyControls';\nimport { MAX_RADIUS, MIN_RADIUS } from '../constants';\nimport { ShotManager } from '../objects/shots/manager';\nimport { PolyClock } from '../clock/PolyClock';\n\n/**\n * Transforms an object based on the supplied controls\n */\nconst MOVEMENT_EPSILON = 0.00001;\n\nexport class ObjectController {\n    private moveState: MoveState;\n    private shotDelta: number;\n\n    private orbitSpeed: number;\n    private rollSpeed: number;\n    private forwardsAndBackwardsSpeed: number;\n    private inertiaFactor: number;\n    private shotRecoveryTime: number;\n\n    constructor(\n        private controls: PolyControls,\n        private object: THREE.Object3D,\n        private shots: ShotManager,\n        private clock: PolyClock\n    ) {\n        this.moveState = getIdleMoveState();\n        this.shotDelta = 0;\n\n        this.orbitSpeed = 0.05;\n        this.rollSpeed = 0.05;\n        this.forwardsAndBackwardsSpeed = 0.5;\n        this.inertiaFactor = 0.1;\n        this.shotRecoveryTime = 0.15;\n\n        this.update();\n    }\n\n    // TODO: Make movement (and probably followCamera) frame independent\n    // See https://github.com/ivoelbert/poly-remake/ssues/2\n    public update = (): void => {\n        // Movement inertia\n        this.moveState = lerpMoveStates(\n            this.moveState,\n            this.controls.moveState,\n            this.inertiaFactor\n        );\n\n        this.updateDepth();\n        this.updateOrbit();\n        this.updateShots();\n    };\n\n    private updateDepth = (): void => {\n        const depthMovement =\n            this.moveState[Movements.backwards] - this.moveState[Movements.forwards];\n        if (Math.abs(depthMovement) > MOVEMENT_EPSILON) {\n            const zOffset = depthMovement * this.forwardsAndBackwardsSpeed;\n\n            let objectRadius = this.object.position.length();\n\n            if (objectRadius + zOffset < MIN_RADIUS) {\n                objectRadius = MIN_RADIUS;\n            } else if (objectRadius + zOffset > MAX_RADIUS) {\n                objectRadius = MAX_RADIUS;\n            } else {\n                objectRadius += zOffset;\n            }\n\n            this.object.position.setLength(objectRadius);\n        }\n    };\n\n    private updateOrbit = (): void => {\n        const xAxis = new THREE.Vector3();\n        const yAxis = new THREE.Vector3();\n        const zAxis = new THREE.Vector3();\n        this.object.matrix.extractBasis(xAxis, yAxis, zAxis);\n\n        const verticalOrbit = this.moveState[Movements.up] - this.moveState[Movements.down];\n        const horizontalOrbit = this.moveState[Movements.right] - this.moveState[Movements.left];\n\n        const verticalVector = xAxis.clone();\n        verticalVector.multiplyScalar(verticalOrbit);\n        const horizontalVector = yAxis.clone();\n        horizontalVector.multiplyScalar(horizontalOrbit);\n\n        const directionVector = new THREE.Vector3()\n            .addVectors(verticalVector, horizontalVector)\n            .clampLength(0, 1);\n        const rotationAngle = directionVector.length();\n\n        if (rotationAngle > MOVEMENT_EPSILON) {\n            directionVector.normalize();\n            this.object.position.applyAxisAngle(directionVector, rotationAngle * this.orbitSpeed);\n        }\n\n        const roll = this.moveState[Movements.rollRight] - this.moveState[Movements.rollLeft];\n        yAxis.applyAxisAngle(zAxis, roll * this.rollSpeed);\n        this.object.up.copy(yAxis);\n        this.object.lookAt(0, 0, 0);\n    };\n\n    private updateShots = (): void => {\n        this.shotDelta += this.clock.getDelta();\n\n        if (this.shotDelta > this.shotRecoveryTime && this.moveState[Movements.shoot] === 1) {\n            this.shotDelta = 0;\n            this.shots.spawn(this.object.position);\n        }\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { MAX_RADIUS } from '../../constants';\nimport { PolyHitbox } from '../hitbox';\nimport { EffectsManager } from '../../effects';\n\nexport class PolyShip implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    constructor(private effects: EffectsManager) {\n        const geometry = this.createGeometry();\n\n        const material = new THREE.MeshBasicMaterial({\n            color: 0xfafafa,\n            wireframe: true,\n        });\n\n        this.mesh = new THREE.Mesh(geometry, material);\n        this.mesh.position.set(0, 0, MAX_RADIUS);\n\n        this.hitbox = new PolyHitbox(this.mesh, geometry);\n    }\n\n    public update = () => {\n        this.hitbox.update();\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        this.effects.glitch();\n    };\n\n    private createGeometry = (): THREE.BufferGeometry => {\n        const geometry = new THREE.BufferGeometry();\n\n        const frontPoint = [0, 0, 1];\n        const backTop = [0, 0.25, 0];\n        const backLeft = [-0.5, -0.25, 0];\n        const backRight = [0.5, -0.25, 0];\n\n        const vertices = new Float32Array([\n            ...frontPoint,\n            ...backTop,\n            ...backLeft,\n\n            ...frontPoint,\n            ...backTop,\n            ...backRight,\n\n            ...frontPoint,\n            ...backLeft,\n            ...backRight,\n\n            ...backTop,\n            ...backLeft,\n            ...backRight,\n        ]);\n\n        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n\n        return geometry;\n    };\n}\n","import * as THREE from 'three';\n\nexport class FollowCamera extends THREE.PerspectiveCamera {\n    private distance: number;\n    private inertiaFactor: number;\n    private followedObject: THREE.Object3D;\n\n    constructor() {\n        super(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n\n        this.distance = 2;\n        this.inertiaFactor = 0.8;\n\n        this.followedObject = new THREE.Object3D();\n    }\n\n    follow = (objectToFollow: THREE.Object3D): void => {\n        this.followedObject = objectToFollow;\n        this.update();\n    };\n\n    // TODO: Make movement (and probably followCamera) frame independent\n    // See https://github.com/ivoelbert/poly-remake/issues/2\n    update = (): void => {\n        const followedPosition = this.followedObject.position.clone();\n        followedPosition.add(followedPosition.clone().normalize().multiplyScalar(this.distance));\n\n        const newPosition = new THREE.Vector3().lerpVectors(\n            this.position,\n            followedPosition,\n            this.inertiaFactor\n        );\n\n        this.position.copy(newPosition);\n        this.up.copy(this.followedObject.up);\n        this.lookAt(0, 0, 0);\n    };\n}\n","import * as THREE from 'three';\n\nexport class PolyRenderer {\n    private renderer: THREE.WebGLRenderer;\n\n    constructor() {\n        this.renderer = new THREE.WebGLRenderer();\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.renderer.toneMappingExposure = Math.pow(1.01, 4.0);\n        this.renderer.outputEncoding = THREE.sRGBEncoding;\n    }\n\n    public getRenderer = (): THREE.WebGLRenderer => {\n        return this.renderer;\n    };\n\n    public getDomElement = (): HTMLCanvasElement => {\n        return this.renderer.domElement;\n    };\n\n    public resize = (): void => {\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n}\n","import * as THREE from 'three';\n\nfunction isRenderItem(obj: any): obj is THREE.RenderItem {\n    return 'geometry' in obj && 'material' in obj;\n}\n\nfunction disposeMaterial(obj: THREE.Object3D) {\n    if (!isRenderItem(obj)) return;\n\n    // because obj.material can be a material or array of materials\n    const materials: THREE.Material[] = ([] as THREE.Material[]).concat(obj.material);\n\n    for (const material of materials) {\n        material.dispose();\n    }\n}\n\nexport class PolyScene {\n    public readonly scene: THREE.Scene;\n\n    constructor() {\n        this.scene = new THREE.Scene();\n        this.scene.fog = new THREE.FogExp2(0x000000, 0.000025);\n\n        const light = new THREE.AmbientLight(0xffffff);\n        this.scene.add(light);\n    }\n\n    public add = (...objects: THREE.Object3D[]) => this.scene.add(...objects);\n\n    public remove = (...objects: THREE.Object3D[]) => this.scene.remove(...objects);\n\n    // TODO: Revisit a better disposing solution\n    public dispose = () => {\n        this.scene.traverse((obj) => {\n            if (!obj) {\n                return;\n            }\n\n            if (isRenderItem(obj)) {\n                if (obj.geometry) {\n                    obj.geometry.dispose();\n                }\n                disposeMaterial(obj);\n            }\n\n            // if we remove children in the same tick then we can't continue traversing,\n            // so we defer to the next microtask\n            Promise.resolve().then(() => {\n                obj.parent && obj.parent.remove(obj);\n            });\n        });\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { DropFunction } from '../manager';\nimport { PolyHitbox } from '../hitbox';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { constrain01, easeOutElastic, linearMap } from '../../utils/easing';\nimport { MAX_RADIUS } from '../../constants';\nimport { ExplosionsManager } from '../explosion/manager';\nimport { AsteroidMeshFactory } from './meshFactory';\n\nconst SPAWN_ANIMATION_TIME = 1;\n\nexport class Asteroid implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    private normal: THREE.Vector3;\n    private angularVelocity: number;\n    private radialVelocity: number;\n\n    private epoch: number;\n\n    constructor(\n        meshFactory: AsteroidMeshFactory,\n        private clock: PolyClock,\n        private explosions: ExplosionsManager,\n        private dropObject: DropFunction<Asteroid>\n    ) {\n        this.mesh = meshFactory.buildMesh();\n        this.hitbox = new PolyHitbox(this.mesh, meshFactory.getHitboxGeometry());\n\n        this.normal = new THREE.Vector3(0, 1, 0);\n\n        this.angularVelocity = 1;\n        this.radialVelocity = 1;\n        this.epoch = 0;\n    }\n\n    public spawn = (position: THREE.Vector3, normal: THREE.Vector3): void => {\n        this.mesh.position.copy(position);\n        this.normal = normal;\n        this.epoch = this.clock.getElapsed();\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        this.drop();\n    };\n\n    public update = (): void => {\n        const delta = this.clock.getDelta();\n        const elapsed = this.clock.getElapsed();\n\n        const lifeTime = elapsed - this.epoch;\n        const timeFactor = constrain01(linearMap(lifeTime, 0, SPAWN_ANIMATION_TIME, 0, 1));\n        const easedTimeFactor = easeOutElastic(timeFactor);\n\n        this.mesh.scale.set(easedTimeFactor, easedTimeFactor, easedTimeFactor);\n\n        // Rotation\n        const angleToRotate = this.angularVelocity * delta;\n        this.mesh.position.applyAxisAngle(this.normal, angleToRotate);\n\n        // radial movement\n        const currentLength = this.mesh.position.length();\n        const lengthOffset = this.radialVelocity * delta;\n        this.mesh.position.setLength(currentLength + lengthOffset);\n\n        this.hitbox.update();\n\n        if (tooFarFromCenter(this.mesh.position)) {\n            this.drop();\n        }\n    };\n\n    private drop = () => {\n        this.explosions.spawn(this.mesh.position.clone());\n        this.dropObject(this);\n    };\n}\n\nfunction tooFarFromCenter(point: THREE.Vector3): boolean {\n    return point.length() > MAX_RADIUS;\n}\n","import * as THREE from 'three';\n\nexport class AsteroidMeshFactory {\n    private mesh: THREE.Mesh;\n    private hitboxGeometry: THREE.BufferGeometry;\n\n    constructor() {\n        this.hitboxGeometry = new THREE.DodecahedronBufferGeometry(1.5);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0x2bfa2b,\n            wireframe: true,\n        });\n\n        this.mesh = new THREE.Mesh(this.hitboxGeometry, material);\n    }\n\n    public buildMesh = (): THREE.Mesh => {\n        return this.mesh.clone() as THREE.Mesh;\n    };\n\n    public getHitboxGeometry = (): THREE.BufferGeometry => {\n        return this.hitboxGeometry.clone();\n    };\n}\n","import { PolyObject } from './objects/polyObject';\n\nexport enum Groups {\n    asteroids,\n    ship,\n    shots,\n    missiles,\n    center,\n}\n\ninterface Collider {\n    addRule: (g1: Groups, g2: Groups) => void;\n    addObjectToGroup: (obj: PolyObject, group: Groups) => void;\n    removeObjectFromGroup: (obj: PolyObject, group: Groups) => void;\n    update: () => void;\n}\n\ntype ColliderGroups = Record<Groups, Set<PolyObject>>;\n\nexport class PolyCollider implements Collider {\n    private rules: Set<[Groups, Groups]>;\n    private groups: ColliderGroups;\n\n    constructor() {\n        this.rules = new Set();\n        this.groups = {\n            [Groups.asteroids]: new Set(),\n            [Groups.ship]: new Set(),\n            [Groups.shots]: new Set(),\n            [Groups.missiles]: new Set(),\n            [Groups.center]: new Set(),\n        };\n    }\n\n    addRule = (g1: Groups, g2: Groups): void => {\n        this.rules.add([g1, g2]);\n    };\n\n    addObjectToGroup = (obj: PolyObject, group: Groups): void => {\n        this.groups[group].add(obj);\n    };\n\n    removeObjectFromGroup = (obj: PolyObject, group: Groups): void => {\n        this.groups[group].delete(obj);\n    };\n\n    update = (): void => {\n        this.rules.forEach(([g1, g2]) => {\n            this.groups[g1].forEach((o1) => {\n                this.groups[g2].forEach((o2) => {\n                    if (polyObjectsCollide(o1, o2)) {\n                        o1.onCollide?.(o2);\n                        o2.onCollide?.(o1);\n                    }\n                });\n            });\n        });\n    };\n}\n\nconst polyObjectsCollide = (o1: PolyObject, o2: PolyObject): boolean => {\n    return o1.hitbox.intersects(o2.hitbox);\n};\n","import { Vector3 } from 'three';\nimport { Asteroid } from './asteroid';\nimport { PolyScene } from '../../scene/PolyScene';\nimport {\n    repeat,\n    getDumpster,\n    randomUnitVector,\n    assertExists,\n    getOne,\n    randomOrthogonalUnitVector,\n} from '../../utils/utils';\nimport { ASTEROIDS_IN_SCENE, CENTER_RADIUS } from '../../constants';\nimport { Manager } from '../manager';\nimport { AsteroidMeshFactory } from './meshFactory';\nimport { PolyCollider, Groups } from '../../collider';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ExplosionsManager } from '../explosion/manager';\n\nexport class AsteroidManager implements Manager<Asteroid> {\n    private idleObjects: Set<Asteroid>;\n    private liveObjects: Set<Asteroid>;\n    private intervalId: NodeJS.Timeout | null;\n\n    constructor(\n        private scene: PolyScene,\n        private collider: PolyCollider,\n        private clock: PolyClock,\n        private explosions: ExplosionsManager\n    ) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n\n        const meshFactory = new AsteroidMeshFactory();\n        repeat(ASTEROIDS_IN_SCENE, (_) => {\n            const object = new Asteroid(meshFactory, this.clock, this.explosions, this.drop);\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n        this.intervalId = null;\n    }\n\n    public start = () => {\n        this.intervalId = setInterval(this.spawnRandom, 3000);\n    };\n\n    public spawn = (position: Vector3, normal: Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position, normal);\n\n        this.collider.addObjectToGroup(objectToSpawn, Groups.asteroids);\n    };\n\n    public drop = (objectToDelete: Asteroid) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n\n        this.collider.removeObjectFromGroup(objectToDelete, Groups.asteroids);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n\n        if (this.intervalId !== null) {\n            clearTimeout(this.intervalId);\n        }\n    };\n\n    private spawnRandom = (): void => {\n        const normal = randomUnitVector();\n        const position = randomOrthogonalUnitVector(normal).setLength(CENTER_RADIUS);\n\n        this.spawn(position, normal);\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { randomUnitVector, MathUtils } from '../../utils/utils';\nimport { MissileMeshFactory } from './meshFactory';\nimport { DropFunction } from '../manager';\nimport { PolyHitbox } from '../hitbox';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ExplosionsManager } from '../explosion/manager';\n\nconst MISSILE_LIFETIME = 7;\n\nexport class FollowMissile implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    private direction: THREE.Vector3;\n    private angSpeed: number;\n    private speed: number;\n\n    private epoch: number;\n\n    constructor(\n        private object: THREE.Object3D,\n        private clock: PolyClock,\n        private explosions: ExplosionsManager,\n        meshFactory: MissileMeshFactory,\n        private dropObject: DropFunction<FollowMissile>\n    ) {\n        this.angSpeed = 3;\n        this.speed = 40;\n\n        this.mesh = meshFactory.buildMesh();\n        this.direction = randomUnitVector();\n\n        this.hitbox = new PolyHitbox(this.mesh, meshFactory.getHitboxGeometry());\n        this.epoch = 0;\n    }\n\n    public spawn = (position: THREE.Vector3, direction: THREE.Vector3): void => {\n        this.epoch = this.clock.getElapsed();\n        this.mesh.position.copy(position);\n        this.direction.copy(direction);\n        this.direction.normalize();\n\n        this.align();\n    };\n\n    public update = (): void => {\n        this.updateRotation();\n        this.updatePosition();\n        this.updateFlames();\n\n        this.hitbox.update();\n\n        const elapsed = this.clock.getElapsed();\n        const lifeTime = elapsed - this.epoch;\n\n        if (lifeTime > MISSILE_LIFETIME) {\n            this.drop();\n        }\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        this.drop();\n    };\n\n    private updateRotation = (): void => {\n        const delta = this.clock.getDelta();\n        const towards = this.object.position.clone();\n        towards.sub(this.mesh.position);\n\n        const angle = this.direction.angleTo(towards);\n        const clampedAngle = MathUtils.clamp(angle, -this.angSpeed * delta, this.angSpeed * delta);\n\n        const normal = new THREE.Vector3().crossVectors(towards, this.direction);\n        normal.normalize();\n\n        this.direction.applyAxisAngle(normal, -clampedAngle);\n        this.align();\n    };\n\n    private updatePosition = (): void => {\n        const delta = this.clock.getDelta();\n        const step = this.direction.clone();\n        step.multiplyScalar(this.speed * delta);\n\n        this.mesh.position.add(step);\n    };\n\n    private updateFlames = (): void => {\n        const delta = this.clock.getDelta();\n        const elapsed = this.clock.getElapsed();\n        this.mesh.children[0].scale.y += Math.sin(elapsed * 10) * 0.05;\n        this.mesh.children[0].rotateY(delta * 10);\n        this.mesh.children[1].scale.y -= Math.cos(elapsed * 10) * 0.05;\n        this.mesh.children[1].rotateY(delta * 10);\n    };\n\n    private align = (): void => {\n        const lookAtPos = this.mesh.position.clone();\n        lookAtPos.add(this.direction);\n        this.mesh.lookAt(lookAtPos);\n        this.mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI * 0.5);\n    };\n\n    private drop = () => {\n        this.explosions.spawn(this.mesh.position.clone());\n        this.dropObject(this);\n    };\n}\n","import * as THREE from 'three';\n\nexport class MissileMeshFactory {\n    private mesh: THREE.Mesh;\n    private hitboxGeometry: THREE.BufferGeometry;\n\n    constructor() {\n        this.hitboxGeometry = new THREE.CylinderBufferGeometry(0.2, 0.4, 1, 6, 1);\n        const misilMaterial = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0xffffff,\n        });\n\n        const fireGeom = new THREE.ConeBufferGeometry(0.3, 1, 6);\n\n        const lightFireMat = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0xeeec74,\n        });\n\n        const darkFireMat = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0xee5137,\n        });\n\n        const lightFire = new THREE.Mesh(fireGeom, lightFireMat);\n        const darkFire = new THREE.Mesh(fireGeom, darkFireMat);\n        lightFire.position.y -= 1;\n        darkFire.position.y -= 1;\n        lightFire.rotateX(Math.PI);\n        darkFire.rotateX(Math.PI);\n\n        this.mesh = new THREE.Mesh(this.hitboxGeometry, misilMaterial);\n        this.mesh.add(lightFire);\n        this.mesh.add(darkFire);\n    }\n\n    public buildMesh = (): THREE.Mesh => {\n        return this.mesh.clone() as THREE.Mesh;\n    };\n\n    public getHitboxGeometry = (): THREE.BufferGeometry => {\n        return this.hitboxGeometry.clone();\n    };\n}\n","import { Vector3 } from 'three';\nimport { FollowMissile } from './followMissile';\nimport { PolyScene } from '../../scene/PolyScene';\nimport {\n    repeat,\n    getDumpster,\n    getOne,\n    assertExists,\n    randomUnitVector,\n    getOrigin,\n} from '../../utils/utils';\nimport { MISSILES_IN_SCENE } from '../../constants';\nimport { Manager } from '../manager';\nimport { MissileMeshFactory } from './meshFactory';\nimport { PolyCollider, Groups } from '../../collider';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ExplosionsManager } from '../explosion/manager';\n\nexport class FollowMissileManager implements Manager<FollowMissile> {\n    private idleObjects: Set<FollowMissile>;\n    private liveObjects: Set<FollowMissile>;\n    private intervalId: NodeJS.Timeout | null;\n\n    constructor(\n        private scene: PolyScene,\n        followedObject: THREE.Object3D,\n        private clock: PolyClock,\n        private collider: PolyCollider,\n        explosions: ExplosionsManager\n    ) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n        const meshFactory = new MissileMeshFactory();\n\n        repeat(MISSILES_IN_SCENE, (_) => {\n            const object = new FollowMissile(\n                followedObject,\n                this.clock,\n                explosions,\n                meshFactory,\n                this.drop\n            );\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n        this.intervalId = null;\n    }\n\n    public start = () => {\n        const initialPosition = getOrigin();\n        this.spawn(initialPosition, randomUnitVector());\n        this.intervalId = setInterval(() => this.spawn(initialPosition, randomUnitVector()), 10000);\n    };\n\n    public spawn = (position: Vector3, direction: Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position, direction);\n\n        this.collider.addObjectToGroup(objectToSpawn, Groups.missiles);\n    };\n\n    public drop = (objectToDelete: FollowMissile) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n\n        this.collider.removeObjectFromGroup(objectToDelete, Groups.missiles);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n\n        if (this.intervalId !== null) {\n            clearInterval(this.intervalId);\n        }\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { DropFunction } from '../manager';\nimport { CENTER_RADIUS } from '../../constants';\nimport { PolyHitbox } from '../hitbox';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ShotMeshFactory } from './meshFactory';\n\nexport class Shot implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    private speed: number;\n\n    constructor(\n        meshFactory: ShotMeshFactory,\n        private clock: PolyClock,\n        private dropObject: DropFunction<Shot>\n    ) {\n        this.mesh = meshFactory.buildMesh();\n        this.hitbox = new PolyHitbox(this.mesh, meshFactory.getHitboxGeometry());\n\n        this.speed = 200;\n    }\n\n    public spawn = (position: THREE.Vector3): void => {\n        this.mesh.position.copy(position);\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        this.drop();\n    };\n\n    public update = (): void => {\n        const delta = this.clock.getDelta();\n\n        const currentLength = this.mesh.position.length();\n        const lengthOffset = this.speed * delta;\n        this.mesh.position.setLength(currentLength - lengthOffset);\n\n        this.hitbox.update();\n\n        if (this.mesh.position.length() <= CENTER_RADIUS) {\n            this.drop();\n        }\n    };\n\n    private drop = () => {\n        this.dropObject(this);\n    };\n}\n","import * as THREE from 'three';\n\nexport class ShotMeshFactory {\n    private mesh: THREE.Mesh;\n    private hitboxGeometry: THREE.BufferGeometry;\n\n    constructor() {\n        const coreGeometry = new THREE.DodecahedronBufferGeometry(0.15);\n        const coreMaterial = new THREE.MeshBasicMaterial({\n            color: 0xfff36e,\n            wireframe: true,\n        });\n\n        const coreMesh = new THREE.Mesh(coreGeometry, coreMaterial);\n\n        this.hitboxGeometry = new THREE.DodecahedronBufferGeometry(0.3);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0xd68400,\n            wireframe: true,\n        });\n\n        this.mesh = new THREE.Mesh(this.hitboxGeometry, material);\n        this.mesh.add(coreMesh);\n    }\n\n    public buildMesh = (): THREE.Mesh => {\n        return this.mesh.clone() as THREE.Mesh;\n    };\n\n    public getHitboxGeometry = (): THREE.BufferGeometry => {\n        return this.hitboxGeometry.clone();\n    };\n}\n","import * as THREE from 'three';\nimport { Shot } from './shot';\nimport { PolyScene } from '../../scene/PolyScene';\nimport { repeat, getDumpster, getOne, assertExists } from '../../utils/utils';\nimport { SHOTS_IN_SCENE } from '../../constants';\nimport { Manager } from '../manager';\nimport { ShotMeshFactory } from './meshFactory';\nimport { PolyCollider, Groups } from '../../collider';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { SoundManager } from '../../soundManager';\n\nexport class ShotManager implements Manager<Shot> {\n    private idleObjects: Set<Shot>;\n    private liveObjects: Set<Shot>;\n\n    constructor(\n        private scene: PolyScene,\n        private collider: PolyCollider,\n        private clock: PolyClock,\n        private sounds: SoundManager\n    ) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n\n        const meshFactory = new ShotMeshFactory();\n        repeat(SHOTS_IN_SCENE, (_) => {\n            const object = new Shot(meshFactory, this.clock, this.drop);\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n    }\n\n    public spawn = (position: THREE.Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position);\n\n        this.collider.addObjectToGroup(objectToSpawn, Groups.shots);\n\n        this.sounds.playShot();\n    };\n\n    public drop = (objectToDelete: Shot) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n\n        this.collider.removeObjectFromGroup(objectToDelete, Groups.shots);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n    };\n}\n","import * as THREE from 'three';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { CENTER_RADIUS } from '../../constants';\nimport { constrain01, linearMap } from '../../utils/easing';\nimport { noop, randFloat } from '../../utils/utils';\nimport { Hitbox, NoCollisionsHitbox } from '../hitbox';\nimport { DropFunction } from '../manager';\nimport { PolyObject } from '../polyObject';\nimport { ExplosionMesh, ExplosionMeshFactory } from './meshFactory';\n\nconst FRAGMENT_LIFETIME = 1;\n\nexport class Explosion implements PolyObject {\n    public hitbox: Hitbox;\n\n    private explosionMesh: ExplosionMesh;\n    private epoch: number;\n    private fragmentSpeeds: number[];\n\n    constructor(\n        meshFactory: ExplosionMeshFactory,\n        private clock: PolyClock,\n        private dropObject: DropFunction<Explosion>\n    ) {\n        this.explosionMesh = meshFactory.buildMesh();\n        this.hitbox = new NoCollisionsHitbox();\n\n        this.epoch = 0;\n        this.fragmentSpeeds = this.getRandomSpeeds();\n    }\n\n    get mesh(): THREE.Mesh {\n        return this.explosionMesh.mesh;\n    }\n\n    spawn = (position: THREE.Vector3): void => {\n        this.mesh.position.copy(position);\n        this.epoch = this.clock.getElapsed();\n        this.fragmentSpeeds = this.getRandomSpeeds();\n        this.explosionMesh.traverseFragments((fragment) => {\n            fragment.setRadiusToCenter(0.1);\n        });\n    };\n\n    onCollide = noop;\n\n    update = (): void => {\n        const elapsed = this.clock.getElapsed();\n        const delta = this.clock.getDelta();\n        const lifeTime = elapsed - this.epoch;\n\n        this.explosionMesh.traverseFragments((fragment, idx) => {\n            const speed = this.fragmentSpeeds[idx];\n            fragment.extendRadius(delta * speed);\n        });\n\n        const materialLifetimeFactor = constrain01(linearMap(lifeTime, 0, FRAGMENT_LIFETIME, 0, 1));\n        this.explosionMesh.updateMaterial(materialLifetimeFactor);\n\n        if (lifeTime > FRAGMENT_LIFETIME) {\n            this.drop();\n        }\n    };\n\n    private getRandomSpeeds = (): number[] => {\n        const speeds: number[] = [];\n        this.explosionMesh.traverseFragments((_) => {\n            const speed = randFloat(0.5 * CENTER_RADIUS, 1 * CENTER_RADIUS);\n            speeds.push(speed);\n        });\n        return speeds;\n    };\n\n    private drop = () => {\n        this.dropObject(this);\n    };\n}\n","import * as THREE from 'three';\nimport { CENTER_RADIUS } from '../../constants';\nimport { randFloat, randomUnitVector } from '../../utils/utils';\n\nconst FRAGMENT_INITIAL_COLOR = new THREE.Color(0xffff96);\nconst FRAGMENT_END_COLOR = new THREE.Color(0x610200);\n\nexport class ExplosionFragmentMesh {\n    public mesh: THREE.Mesh;\n\n    constructor(material: THREE.MeshBasicMaterial) {\n        const fragmentSize = randFloat(CENTER_RADIUS * 0.05, CENTER_RADIUS * 0.2);\n        const fragmentGeometry = new THREE.TetrahedronBufferGeometry(fragmentSize);\n\n        this.mesh = new THREE.Mesh(fragmentGeometry, material);\n    }\n\n    setPosition = (x: number, y: number, z: number) => {\n        this.mesh.position.set(x, y, z);\n    };\n\n    setRadiusToCenter = (r: number) => {\n        this.mesh.position.setLength(r);\n    };\n\n    extendRadius = (amount: number) => {\n        const dir = this.mesh.position.clone().setLength(amount);\n        this.mesh.position.add(dir);\n    };\n}\n\nexport class ExplosionMesh {\n    public mesh: THREE.Mesh;\n    private fragments: ExplosionFragmentMesh[];\n    private fragmentMaterial: THREE.MeshBasicMaterial;\n\n    constructor() {\n        this.mesh = new THREE.Mesh();\n\n        this.fragmentMaterial = new THREE.MeshBasicMaterial({\n            color: FRAGMENT_INITIAL_COLOR,\n            wireframe: true,\n            transparent: true,\n        });\n\n        this.fragments = this.buildFragments();\n\n        const rotationAngle = randFloat(0, 2 * Math.PI);\n        this.mesh.rotateOnAxis(randomUnitVector(), rotationAngle);\n    }\n\n    traverseFragments = (cb: (fragment: ExplosionFragmentMesh, idx: number) => void) => {\n        this.fragments.forEach((fragment, idx) => cb(fragment, idx));\n    };\n\n    updateMaterial = (lifetimeFactor: number) => {\n        const opacity = 1 - lifetimeFactor;\n        const color = new THREE.Color(FRAGMENT_INITIAL_COLOR).lerp(\n            FRAGMENT_END_COLOR,\n            lifetimeFactor\n        );\n\n        this.fragmentMaterial.opacity = opacity;\n        this.fragmentMaterial.color = color;\n    };\n\n    private buildFragments = (): ExplosionFragmentMesh[] => {\n        const initialPositions = new THREE.SphereGeometry(0.1, 6, 6).getAttribute('position');\n\n        const fragments: ExplosionFragmentMesh[] = [];\n        for (let i = 0; i < initialPositions.count; i++) {\n            const x = initialPositions.getX(i);\n            const y = initialPositions.getY(i);\n            const z = initialPositions.getZ(i);\n\n            const fragment = new ExplosionFragmentMesh(this.fragmentMaterial);\n            fragment.setPosition(x, y, z);\n            this.mesh.add(fragment.mesh);\n            fragments.push(fragment);\n        }\n\n        return fragments;\n    };\n}\n\nexport class ExplosionMeshFactory {\n    public buildMesh = (): ExplosionMesh => {\n        return new ExplosionMesh();\n    };\n}\n","import { PolyClock } from '../../clock/PolyClock';\nimport { EXPLOSIONS_IN_SCENE } from '../../constants';\nimport { PolyScene } from '../../scene/PolyScene';\nimport { assertExists, getDumpster, getOne, repeat } from '../../utils/utils';\nimport { Manager } from '../manager';\nimport { Explosion } from './explosion';\nimport { ExplosionMeshFactory } from './meshFactory';\n\nexport class ExplosionsManager implements Manager<Explosion> {\n    private idleObjects: Set<Explosion>;\n    private liveObjects: Set<Explosion>;\n\n    constructor(private scene: PolyScene, private clock: PolyClock) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n\n        const meshFactory = new ExplosionMeshFactory();\n        repeat(EXPLOSIONS_IN_SCENE, (_) => {\n            const object = new Explosion(meshFactory, this.clock, this.drop);\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n    }\n\n    public spawn = (position: THREE.Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position);\n    };\n\n    public drop = (objectToDelete: Explosion) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n    };\n}\n","import * as Tone from 'tone';\nimport { noop } from './utils/utils';\n\nexport interface SoundManager {\n    playShot(): void;\n    playPickup(): void;\n    dispose(): void;\n}\n\nexport class SilentSoundManager implements SoundManager {\n    playShot = noop;\n    playPickup = noop;\n    dispose = noop;\n}\n\nexport class ToneSoundManager implements SoundManager {\n    private synth: Tone.Synth;\n\n    constructor() {\n        this.synth = new Tone.Synth().toDestination();\n    }\n\n    playShot = () => {\n        const now = Tone.now();\n        this.synth.triggerAttackRelease('G1', '32n', now);\n    };\n\n    playPickup = () => {\n        const now = Tone.now();\n        this.synth.triggerAttackRelease('C5', '32n', now);\n        this.synth.triggerAttackRelease('E5', '32n', now + 0.05);\n        this.synth.triggerAttackRelease('G5', '32n', now + 0.1);\n    };\n\n    dispose = () => {\n        this.synth.dispose();\n    };\n}\n","import { CancelAction, VoidCallback } from '../utils/utils';\n\nexport class Scheduler {\n    static after = (ms: number, cb: VoidCallback): CancelAction => {\n        const timeoutId = setTimeout(cb, ms);\n\n        return () => {\n            clearTimeout(timeoutId);\n        };\n    };\n}\n","import * as THREE from 'three';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';\nimport { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';\nimport { Scheduler } from './clock/scheduler';\nimport { PolyRenderer } from './renderer';\nimport { PolyScene } from './scene/PolyScene';\nimport { noop, VoidCallback } from './utils/utils';\n\nexport class EffectsManager {\n    private composer: EffectComposer;\n    private renderer: THREE.WebGLRenderer;\n\n    private renderPass: RenderPass;\n    private bloomPass: PolyBloom;\n    private glitchPass: PolyGlitch;\n\n    constructor(renderer: PolyRenderer, scene: PolyScene, camera: THREE.Camera) {\n        this.renderer = renderer.getRenderer();\n\n        this.renderPass = new RenderPass(scene.scene, camera);\n\n        this.bloomPass = new PolyBloom();\n\n        this.glitchPass = new PolyGlitch();\n\n        this.composer = new EffectComposer(this.renderer);\n        this.composer.addPass(this.renderPass);\n        this.composer.addPass(this.bloomPass);\n        this.composer.addPass(this.glitchPass);\n        this.composer.renderToScreen = true;\n    }\n\n    glitch = (): void => {\n        this.glitchPass.trigger();\n    };\n\n    resize = (): void => {\n        const w = window.innerWidth;\n        const h = window.innerHeight;\n        this.renderPass.setSize(w, h);\n        this.bloomPass.setSize(w, h);\n        this.glitchPass.setSize(w, h);\n        this.composer.setSize(w, h);\n        this.renderer.setSize(w, h);\n    };\n\n    render = (): void => {\n        this.composer.render();\n    };\n}\n\nconst BLOOM_PARAMS = {\n    bloomStrength: 1.1,\n    bloomThreshold: 0,\n    bloomRadius: 0,\n};\n\nclass PolyBloom extends UnrealBloomPass {\n    constructor() {\n        super(\n            new THREE.Vector2(window.innerWidth, window.innerHeight),\n            BLOOM_PARAMS.bloomStrength,\n            BLOOM_PARAMS.bloomRadius,\n            BLOOM_PARAMS.bloomThreshold\n        );\n    }\n}\n\nclass PolyGlitch extends GlitchPass {\n    private cancelGlitch: VoidCallback;\n\n    constructor() {\n        super();\n        this.goWild = true;\n        this.enabled = false;\n        this.cancelGlitch = noop;\n    }\n\n    trigger = () => {\n        this.cancelGlitch();\n\n        this.enabled = true;\n        this.cancelGlitch = Scheduler.after(750, () => {\n            this.enabled = false;\n        });\n    };\n}\n","import { Stars } from './objects/stars/stars';\nimport { consoleInfo } from './utils/utils';\nimport { Center } from './objects/center';\nimport { KeyboardControls } from './controls/keyboardControls';\nimport { PolyClock } from './clock/PolyClock';\nimport { ObjectController } from './controls/objectController';\nimport { PolyShip } from './objects/ship/ship';\nimport { FollowCamera } from './objects/followCamera';\nimport { PolyRenderer } from './renderer';\nimport { PolyScene } from './scene/PolyScene';\nimport { AsteroidManager } from './objects/asteroid/manager';\nimport { FollowMissileManager } from './objects/followMissile/manager';\nimport { ShotManager } from './objects/shots/manager';\nimport { PolyCollider, Groups } from './collider';\nimport { ExplosionsManager } from './objects/explosion/manager';\nimport { SilentSoundManager, SoundManager } from './soundManager';\nimport { EffectsManager } from './effects';\n\nexport class Polybius {\n    private renderer: PolyRenderer;\n    private clock: PolyClock;\n    private camera: FollowCamera;\n    private keyboardControls: KeyboardControls;\n    private objectController: ObjectController;\n    private center: Center;\n    private ship: PolyShip;\n    private scene: PolyScene;\n    private effects: EffectsManager;\n    private explosions: ExplosionsManager;\n    private asteroids: AsteroidManager;\n    private missiles: FollowMissileManager;\n    private shots: ShotManager;\n    private collider: PolyCollider;\n    private sounds: SoundManager;\n\n    constructor() {\n        // Set up the scene\n        this.scene = new PolyScene();\n\n        // Set up camera\n        this.camera = new FollowCamera();\n\n        // Set up the renderer\n        this.renderer = new PolyRenderer();\n\n        // Set up the clock\n        this.clock = new PolyClock();\n\n        // Set up the collider\n        this.collider = new PolyCollider();\n        this.collider.addRule(Groups.asteroids, Groups.ship);\n        this.collider.addRule(Groups.shots, Groups.asteroids);\n        this.collider.addRule(Groups.shots, Groups.center);\n        this.collider.addRule(Groups.shots, Groups.missiles);\n        this.collider.addRule(Groups.missiles, Groups.ship);\n\n        /**\n         * TODO: iron out sounds and use the ToneSoundManager\n         */\n        this.sounds = new SilentSoundManager();\n\n        this.explosions = new ExplosionsManager(this.scene, this.clock);\n\n        this.effects = new EffectsManager(this.renderer, this.scene, this.camera);\n        this.effects.resize();\n\n        // Set up the ship\n        this.ship = new PolyShip(this.effects);\n        this.collider.addObjectToGroup(this.ship, Groups.ship);\n\n        this.camera.follow(this.ship.mesh);\n\n        // Set up various objects and managers\n        const stars = new Stars();\n        this.center = new Center(this.clock);\n        this.collider.addObjectToGroup(this.center, Groups.center);\n\n        this.scene.add(this.ship.mesh, stars.mesh, this.center.mesh);\n\n        this.asteroids = new AsteroidManager(\n            this.scene,\n            this.collider,\n            this.clock,\n            this.explosions\n        );\n        this.missiles = new FollowMissileManager(\n            this.scene,\n            this.ship.mesh,\n            this.clock,\n            this.collider,\n            this.explosions\n        );\n        this.shots = new ShotManager(this.scene, this.collider, this.clock, this.sounds);\n\n        /**\n         * TODO: iron out the orientation controls and figure out what controls to use\n         * or provide a way to use both.\n         */\n        this.keyboardControls = new KeyboardControls();\n        this.objectController = new ObjectController(\n            this.keyboardControls,\n            this.ship.mesh,\n            this.shots,\n            this.clock\n        );\n    }\n\n    start = (): void => {\n        this.keyboardControls.attachListeners();\n        window.addEventListener('resize', this.resize);\n\n        this.asteroids.start();\n        this.missiles.start();\n\n        // Start the render loop!\n        consoleInfo('Game started!');\n        this.animate();\n    };\n\n    dispose = (): void => {\n        this.keyboardControls.dispose();\n        this.asteroids.dispose();\n        this.missiles.dispose();\n        this.explosions.dispose();\n        this.sounds.dispose();\n\n        this.scene.dispose();\n        window.removeEventListener('resize', this.resize);\n    };\n\n    getDomElement = (): HTMLCanvasElement => {\n        return this.renderer.getDomElement();\n    };\n\n    private resize = (): void => {\n        this.effects.resize();\n        this.camera.aspect = window.innerWidth / window.innerHeight;\n        this.camera.updateProjectionMatrix();\n    };\n\n    // This function represents a frame. It's called once for every frame.\n    private animate = (): void => {\n        this.clock.tick();\n\n        this.objectController.update();\n        this.ship.update();\n        this.center.update();\n\n        this.missiles.update();\n        this.asteroids.update();\n        this.shots.update();\n        this.explosions.update();\n\n        this.collider.update();\n\n        this.camera.update();\n        this.effects.render();\n        requestAnimationFrame(this.animate);\n    };\n}\n","import { useEffect } from 'react';\nimport { Polybius } from '../game/polybius';\nimport { assertExists } from '../game/utils/utils';\nimport { useLazyRef } from './useLazyRef';\n\ntype CallbackRef = (element: HTMLElement | null) => void;\n\nexport const usePolybius = (): CallbackRef => {\n    const polybius = useLazyRef(() => new Polybius());\n\n    useEffect(() => {\n        polybius.start();\n\n        return () => polybius.dispose();\n    }, [polybius]);\n\n    const callbackRef = (element: HTMLElement | null): void => {\n        assertExists(element).appendChild(polybius.getDomElement());\n    };\n\n    return callbackRef;\n};\n","import { useRef } from 'react';\n\nexport type InitRef<T> = () => T;\n\nexport function useLazyRef<T>(init: InitRef<T>) {\n    const ref = useRef<T | null>(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n\n    return ref.current;\n}\n","import * as React from 'react';\nimport { usePolybius } from './hooks/usePolybius';\n\nfunction GameComponent() {\n    const polybiusRef = usePolybius();\n\n    return <div className=\"game-container\" ref={polybiusRef} />;\n}\n\nexport default GameComponent;\n"],"sourceRoot":""}