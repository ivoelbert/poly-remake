{"version":3,"sources":["game/utils/utils.ts","game/constants.ts","game/objects/stars/stars.ts","game/objects/hitbox.ts","game/utils/easing.ts","game/objects/center.ts","game/controls/polyControls.ts","game/controls/keyboardControls.ts","game/clock/PolyClock.ts","game/controls/objectController.ts","game/objects/ship/ship.ts","game/objects/followCamera.ts","game/renderer.ts","game/scene/PolyScene.ts","game/objects/asteroid/asteroid.ts","game/objects/asteroid/meshFactory.ts","game/collider.ts","game/objects/asteroid/manager.ts","game/objects/followMissile/followMissile.ts","game/objects/followMissile/meshFactory.ts","game/objects/followMissile/manager.ts","game/objects/shots/shot.ts","game/objects/shots/meshFactory.ts","game/objects/shots/manager.ts","game/objects/explosion/explosion.ts","game/objects/explosion/meshFactory.ts","game/objects/explosion/manager.ts","game/soundManager.ts","game/polybius.ts","hooks/usePolybius.ts","hooks/useLazyRef.ts","GameComponent.tsx"],"names":["repeat","THREE","times","f","i","MathUtils","randFloat","min","max","Math","random","randomUnitVector","normalize","chance","p","getDumpster","CENTER_RADIUS","isNil","value","undefined","assertExists","msg","UnexpectedNilError","Error","noop","getOne","set","values","next","Stars","mesh","createStarsGeometry","starsGeometry","vertices","distance","push","setAttribute","this","color","size","sizeAttenuation","forEach","material","geometry","stars","matrixAutoUpdate","updateMatrix","add","PolyHitbox","followedObject","shape","hitboxDebug","debug","scene","radius","wireframe","update","objectPosition","position","clone","center","copy","intersects","hitbox","intersectsSphere","internalGeometry","computeBoundingSphere","boundingSphere","NoCollisionsHitbox","linearMap","x","a1","a2","b1","b2","mapLinear","constrain01","lo","hi","constrain","Movements","Center","clock","elapsed","getElapsed","scale","sin","centerMesh","getIdleMoveState","up","down","left","right","forwards","backwards","rollLeft","rollRight","shoot","KeyboardControls","moveState","keyMapping","bindKey","key","movement","attachListeners","window","addEventListener","keyDownHandler","keyUpHandler","dispose","e","get","code","Map","getDefaultKeyMapping","PolyClock","delta","getDelta","tick","getElapsedTime","ObjectController","controls","object","shots","shotDelta","orbitSpeed","rollSpeed","forwardsAndBackwardsSpeed","inertiaFactor","shotRecoveryTime","moveState1","moveState2","factor","lerp","lerpMoveStates","updateDepth","updateOrbit","updateShots","depthMovement","abs","zOffset","objectRadius","length","setLength","xAxis","yAxis","zAxis","matrix","extractBasis","verticalOrbit","horizontalOrbit","verticalVector","multiplyScalar","horizontalVector","directionVector","addVectors","clampLength","rotationAngle","applyAxisAngle","roll","lookAt","spawn","PolyShip","onCollide","who","console","log","createGeometry","frontPoint","backTop","backLeft","backRight","Float32Array","FollowCamera","innerWidth","innerHeight","followedPosition","newPosition","lerpVectors","BLOOM_PARAMS","PolyRenderer","camera","renderer","composer","getDomElement","domElement","resize","setSize","render","toneMappingExposure","pow","outputEncoding","renderScene","RenderPass","bloomPass","UnrealBloomPass","EffectComposer","renderToScreen","addPass","isRenderItem","obj","PolyScene","remove","traverse","materials","concat","disposeMaterial","Promise","resolve","then","parent","fog","light","Asteroid","meshFactory","explosions","dropObject","normal","angularVelocity","radialVelocity","epoch","drop","easedTimeFactor","c4","PI","easeOutElastic","angleToRotate","currentLength","lengthOffset","buildMesh","getHitboxGeometry","Groups","AsteroidMeshFactory","hitboxGeometry","PolyCollider","rules","groups","addRule","g1","g2","addObjectToGroup","group","removeObjectFromGroup","delete","o1","o2","polyObjectsCollide","Set","asteroids","ship","missiles","AsteroidManager","collider","idleObjects","liveObjects","intervalId","start","setInterval","spawnRandom","objectToSpawn","objectToDelete","clearTimeout","vec","mostPerpendicular","reduce","best","current","dot","negate","crossVectors","randomOrthogonalUnitVector","_","FollowMissile","direction","angSpeed","speed","align","updateRotation","updatePosition","updateFlames","towards","sub","angle","angleTo","clampedAngle","clamp","step","children","y","rotateY","cos","lookAtPos","rotateOnAxis","MissileMeshFactory","misilMaterial","fireGeom","lightFireMat","darkFireMat","lightFire","darkFire","rotateX","FollowMissileManager","initialPosition","clearInterval","Shot","ShotMeshFactory","coreGeometry","coreMaterial","coreMesh","ShotManager","sounds","playShot","Explosion","explosionMesh","fragmentSpeeds","getRandomSpeeds","traverseFragments","fragment","setRadiusToCenter","lifeTime","idx","extendRadius","materialLifetimeFactor","updateMaterial","speeds","FRAGMENT_INITIAL_COLOR","FRAGMENT_END_COLOR","ExplosionFragmentMesh","setPosition","z","r","amount","dir","fragmentSize","fragmentGeometry","ExplosionMesh","fragments","fragmentMaterial","cb","lifetimeFactor","opacity","buildFragments","initialPositions","getAttribute","count","getX","getY","getZ","transparent","ExplosionMeshFactory","ExplosionsManager","SilentSoundManager","playPickup","Polybius","keyboardControls","objectController","message","animate","removeEventListener","aspect","updateProjectionMatrix","requestAnimationFrame","usePolybius","polybius","init","ref","useRef","useLazyRef","useEffect","element","appendChild","GameComponent","polybiusRef","className"],"mappings":"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","file":"static/js/4.8c52b94e.chunk.js","sourcesContent":["import * as THREE from 'three';\nimport { CENTER_RADIUS } from '../constants';\n\ntype RepeatFunction = (index: number) => void;\nexport const repeat = (times: number, f: RepeatFunction) => {\n    for (let i = 0; i < times; i++) {\n        f(i);\n    }\n};\n\nexport const MathUtils = THREE.MathUtils;\n\nexport function randFloat(min: number, max: number) {\n    return Math.random() * (max - min) + min;\n}\n\nexport const randomUnitVector = (): THREE.Vector3 => {\n    return new THREE.Vector3(randFloat(-1, 1), randFloat(-1, 1), randFloat(-1, 1)).normalize();\n};\n\nexport const randomOrthogonalUnitVector = (vec: THREE.Vector3): THREE.Vector3 => {\n    const x = new THREE.Vector3(1, 0, 0);\n    const y = new THREE.Vector3(0, 1, 0);\n    const z = new THREE.Vector3(0, 0, 1);\n\n    const mostPerpendicular = [y, z].reduce((best, current) => {\n        if (vec.dot(best) > vec.dot(current)) {\n            return current;\n        }\n        return best;\n    }, x);\n\n    if (chance(0.5)) {\n        mostPerpendicular.negate();\n    }\n\n    return new THREE.Vector3().crossVectors(vec, mostPerpendicular);\n};\n\nexport const randomTinyVector = (): THREE.Vector3 => {\n    return randomUnitVector().setLength(0.00001);\n};\n\nexport const getOrigin = (): THREE.Vector3 => {\n    return new THREE.Vector3(0, 0, 0);\n};\n\nexport const chance = (p: number): boolean => {\n    return randFloat(0, 1) < p;\n};\n\n// The dumpster has to be very, very far from the center so the camera doesn't catch it.\nconst DUMPSTER_POSITION = CENTER_RADIUS * 1000;\nexport const getDumpster = (): THREE.Vector3 => {\n    return new THREE.Vector3(DUMPSTER_POSITION, DUMPSTER_POSITION, DUMPSTER_POSITION);\n};\n\nexport type nil = undefined | null;\n\nexport const isNil = (value: any): value is nil => {\n    return value === undefined || value === null;\n};\n\nexport const assertExists = <T>(value: T | nil, msg?: string): T => {\n    if (isNil(value)) {\n        throw new UnexpectedNilError(msg);\n    } else {\n        return value;\n    }\n};\n\nexport class UnexpectedNilError extends Error {\n    constructor(msg?: string) {\n        super(msg ?? 'Unexpected nil value!');\n    }\n}\n\nexport const consoleInfo = (message: string): void => {\n    const styles = `\n        background-color: #dadada;\n        color: #2b2bfa;\n        margin: 1em;\n        padding: 0.5em 1em;\n        border-radius: 9999px;\n        font-size: 14px;\n        text-align: center;\n        font-weight: 800;\n    `;\n    console.log(`%c${message}`, styles);\n};\n\nexport const noop = () => {};\n\nexport const getOne = <T>(set: Set<T>): T | nil => {\n    return set.values().next().value;\n};\n\nexport const debug = (info: string): void => {\n    const debugElement = assertExists(document.getElementById('debug-element'));\n    debugElement.style.display = 'block';\n    debugElement.textContent = info;\n};\n","import * as THREE from 'three';\n\nexport const CENTER_RADIUS = 5;\nexport const MIN_RADIUS = 3 * CENTER_RADIUS;\nexport const MAX_RADIUS = 10 * CENTER_RADIUS;\n\nexport const CENTER = new THREE.Vector3();\n\nexport const ASTEROIDS_IN_SCENE = 50;\nexport const MISSILES_IN_SCENE = 50;\nexport const SHOTS_IN_SCENE = 20;\nexport const EXPLOSIONS_IN_SCENE = 50;\n","import * as THREE from 'three';\nimport { repeat, MathUtils } from '../../utils/utils';\nimport { CENTER_RADIUS } from '../../constants';\n\nexport class Stars {\n    public mesh: THREE.Group;\n\n    constructor() {\n        this.mesh = new THREE.Group();\n\n        const starsMaterials = [\n            new THREE.PointsMaterial({\n                color: 0x555555,\n                size: 2,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x555555,\n                size: 1,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x333333,\n                size: 2,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x3a3a3a,\n                size: 1,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x1a1a1a,\n                size: 2,\n                sizeAttenuation: false,\n            }),\n            new THREE.PointsMaterial({\n                color: 0x1a1a1a,\n                size: 1,\n                sizeAttenuation: false,\n            }),\n        ];\n\n        starsMaterials.forEach((material) => {\n            const geometry = this.createStarsGeometry();\n            const stars = new THREE.Points(geometry, material);\n            stars.matrixAutoUpdate = false;\n            stars.updateMatrix();\n\n            this.mesh.add(stars);\n        });\n    }\n\n    private createStarsGeometry = (): THREE.BufferGeometry => {\n        const starsGeometry = new THREE.BufferGeometry();\n\n        const vertices: number[] = [];\n        repeat(1000, (i: number) => {\n            const distance = MathUtils.randFloat(CENTER_RADIUS * 20, CENTER_RADIUS * 100);\n\n            vertices.push(\n                MathUtils.randFloat(-1, 1) * distance,\n                MathUtils.randFloat(-1, 1) * distance,\n                MathUtils.randFloat(-1, 1) * distance\n            );\n        });\n\n        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n        return starsGeometry;\n    };\n}\n","import * as THREE from 'three';\nimport { assertExists, getDumpster, isNil } from '../utils/utils';\nimport { PolyScene } from '../scene/PolyScene';\n\nexport interface Hitbox {\n    intersects(hitbox: Hitbox): boolean;\n    shape: THREE.Sphere;\n}\n\nexport class PolyHitbox implements Hitbox {\n    readonly shape: THREE.Sphere;\n    private hitboxDebug: THREE.Mesh | null;\n\n    constructor(private followedObject: THREE.Object3D, geometry: THREE.BufferGeometry) {\n        const internalGeometry = geometry.clone();\n        internalGeometry.computeBoundingSphere();\n        this.shape = assertExists(internalGeometry.boundingSphere);\n\n        this.hitboxDebug = null;\n\n        this.update();\n    }\n\n    debug = (scene: PolyScene): void => {\n        const geometry = new THREE.SphereBufferGeometry(this.shape.radius, 8, 6);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0x324ca8,\n            wireframe: true,\n        });\n\n        this.hitboxDebug = new THREE.Mesh(geometry, material);\n\n        scene.add(this.hitboxDebug);\n\n        this.update();\n    };\n\n    update = (): void => {\n        const objectPosition = this.followedObject.position.clone();\n        this.shape.center.copy(objectPosition);\n        if (!isNil(this.hitboxDebug)) {\n            this.hitboxDebug.position.copy(objectPosition);\n        }\n    };\n\n    intersects = (hitbox: Hitbox): boolean => {\n        return this.shape.intersectsSphere(hitbox.shape);\n    };\n}\n\nexport class NoCollisionsHitbox implements Hitbox {\n    readonly shape: THREE.Sphere = new THREE.Sphere(getDumpster(), 0);\n\n    intersects = (hitbox: Hitbox): boolean => {\n        return false;\n    };\n}\n","import * as THREE from 'three';\n\nexport function linearMap(x: number, a1: number, a2: number, b1: number, b2: number): number {\n    return THREE.MathUtils.mapLinear(x, a1, a2, b1, b2);\n}\n\nexport function constrain(x: number, lo: number, hi: number): number {\n    if (x < lo) {\n        return lo;\n    }\n\n    if (x > hi) {\n        return hi;\n    }\n\n    return x;\n}\n\nexport function constrain01(x: number): number {\n    return constrain(x, 0, 1);\n}\n\nexport function easeOutElastic(x: number): number {\n    const c4 = (2 * Math.PI) / 3;\n\n    return x === 0 ? 0 : x === 1 ? 1 : 2 ** (-10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;\n}\n","import * as THREE from 'three';\nimport { PolyObject } from './polyObject';\nimport { CENTER_RADIUS } from '../constants';\nimport { PolyHitbox } from './hitbox';\nimport { PolyClock } from '../clock/PolyClock';\nimport { linearMap } from '../utils/easing';\n\nexport class Center implements PolyObject {\n    public mesh: THREE.Group;\n    public hitbox: PolyHitbox;\n\n    constructor(private clock: PolyClock) {\n        this.mesh = new THREE.Group();\n\n        const geometry = new THREE.SphereBufferGeometry(CENTER_RADIUS, 16, 12);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0xfa2b2b,\n            wireframe: true,\n        });\n\n        const centerMesh = new THREE.Mesh(geometry, material);\n        this.mesh.add(centerMesh);\n\n        this.hitbox = new PolyHitbox(this.mesh, geometry);\n    }\n\n    update = () => {\n        const elapsed = this.clock.getElapsed();\n\n        const scale = linearMap(Math.sin(elapsed * 10), -1, 1, 0.99, 1.01);\n\n        this.mesh.scale.set(scale, scale, scale);\n    };\n}\n","import { MathUtils } from '../utils/utils';\n\n// All posible inputs\nexport enum Movements {\n    up = 'up',\n    down = 'down',\n    left = 'left',\n    right = 'right',\n    forwards = 'forwards',\n    backwards = 'backwards',\n    rollLeft = 'rollLeft',\n    rollRight = 'rollRight',\n    shoot = 'shoot',\n}\n\n/**\n * for each possible movement we have a number in [0, 1] instead of a boolean\n * so we can support analog input\n */\nexport type MoveState = Record<Movements, number>;\n\nexport const getIdleMoveState = (): MoveState => ({\n    [Movements.up]: 0,\n    [Movements.down]: 0,\n    [Movements.left]: 0,\n    [Movements.right]: 0,\n    [Movements.forwards]: 0,\n    [Movements.backwards]: 0,\n    [Movements.rollLeft]: 0,\n    [Movements.rollRight]: 0,\n    [Movements.shoot]: 0,\n});\n\nexport const lerpMoveStates = (\n    moveState1: MoveState,\n    moveState2: MoveState,\n    factor: number\n): MoveState => ({\n    [Movements.up]: MathUtils.lerp(moveState1[Movements.up], moveState2[Movements.up], factor),\n    [Movements.down]: MathUtils.lerp(\n        moveState1[Movements.down],\n        moveState2[Movements.down],\n        factor\n    ),\n    [Movements.left]: MathUtils.lerp(\n        moveState1[Movements.left],\n        moveState2[Movements.left],\n        factor\n    ),\n    [Movements.right]: MathUtils.lerp(\n        moveState1[Movements.right],\n        moveState2[Movements.right],\n        factor\n    ),\n    [Movements.forwards]: MathUtils.lerp(\n        moveState1[Movements.forwards],\n        moveState2[Movements.forwards],\n        factor\n    ),\n    [Movements.backwards]: MathUtils.lerp(\n        moveState1[Movements.backwards],\n        moveState2[Movements.backwards],\n        factor\n    ),\n    [Movements.rollLeft]: MathUtils.lerp(\n        moveState1[Movements.rollLeft],\n        moveState2[Movements.rollLeft],\n        factor\n    ),\n    [Movements.rollRight]: MathUtils.lerp(\n        moveState1[Movements.rollRight],\n        moveState2[Movements.rollRight],\n        factor\n    ),\n    [Movements.shoot]: moveState2[Movements.shoot],\n});\n\n// All controls must expost a move state\nexport interface PolyControls {\n    moveState: MoveState;\n}\n","import { isNil } from '../utils/utils';\nimport { Movements, MoveState, getIdleMoveState, PolyControls } from './polyControls';\n\n/**\n * PolyControls.\n *\n * This module takes care of binding keys to movements\n * and exposing an object that represents the current input\n * abstracted away from the actual keys that are being pressed\n */\n\n// Map movements to key 'code'\nexport type KeyMapping = Map<string, Movements>;\n\n// Default key binding\nexport const getDefaultKeyMapping = (): KeyMapping => {\n    const keyMapping = new Map();\n    keyMapping.set('KeyW', Movements.up);\n    keyMapping.set('KeyS', Movements.down);\n    keyMapping.set('KeyA', Movements.left);\n    keyMapping.set('KeyD', Movements.right);\n    keyMapping.set('KeyI', Movements.forwards);\n    keyMapping.set('KeyK', Movements.backwards);\n    keyMapping.set('KeyJ', Movements.rollLeft);\n    keyMapping.set('KeyL', Movements.rollRight);\n    keyMapping.set('Space', Movements.shoot);\n\n    return keyMapping;\n};\n\nexport class KeyboardControls implements PolyControls {\n    public moveState: MoveState;\n    private keyMapping: KeyMapping;\n\n    constructor() {\n        this.moveState = getIdleMoveState();\n        this.keyMapping = getDefaultKeyMapping();\n    }\n\n    // When binding a key reset the moveState to avoid locking buttons.\n    public bindKey = (key: string, movement: Movements): void => {\n        this.keyMapping.set(key, movement);\n        this.moveState = getIdleMoveState();\n    };\n\n    public attachListeners = (): void => {\n        window.addEventListener('keydown', this.keyDownHandler);\n        window.addEventListener('keyup', this.keyUpHandler);\n    };\n\n    public dispose = (): void => {\n        window.addEventListener('keydown', this.keyDownHandler);\n        window.addEventListener('keyup', this.keyUpHandler);\n    };\n\n    private keyDownHandler = (e: KeyboardEvent): void => {\n        const movement = this.keyMapping.get(e.code);\n\n        if (isNil(movement)) {\n            return;\n        }\n\n        this.moveState[movement] = 1;\n    };\n\n    private keyUpHandler = (e: KeyboardEvent): void => {\n        const movement = this.keyMapping.get(e.code);\n\n        if (isNil(movement)) {\n            return;\n        }\n\n        this.moveState[movement] = 0;\n    };\n}\n","import * as THREE from 'three';\n\n/**\n * The delta and elapsed must be recomputed with `tick` on every render\n */\nexport interface ClockTick {\n    delta: number;\n    elapsed: number;\n}\n\nexport class PolyClock {\n    private clock: THREE.Clock;\n    private delta: number;\n    private elapsed: number;\n\n    constructor() {\n        // Autostarts\n        this.clock = new THREE.Clock();\n        this.delta = 0;\n        this.elapsed = 0;\n    }\n\n    public getDelta = (): number => {\n        return this.delta;\n    };\n\n    public getElapsed = (): number => {\n        return this.elapsed;\n    };\n\n    public tick = (): void => {\n        this.delta = this.clock.getDelta();\n        this.elapsed = this.clock.getElapsedTime();\n    };\n}\n","import * as THREE from 'three';\nimport {\n    PolyControls,\n    Movements,\n    MoveState,\n    getIdleMoveState,\n    lerpMoveStates,\n} from './polyControls';\nimport { MAX_RADIUS, MIN_RADIUS } from '../constants';\nimport { ShotManager } from '../objects/shots/manager';\nimport { PolyClock } from '../clock/PolyClock';\n\n/**\n * Transforms an object based on the supplied controls\n */\nconst MOVEMENT_EPSILON = 0.00001;\n\nexport class ObjectController {\n    private moveState: MoveState;\n    private shotDelta: number;\n\n    private orbitSpeed: number;\n    private rollSpeed: number;\n    private forwardsAndBackwardsSpeed: number;\n    private inertiaFactor: number;\n    private shotRecoveryTime: number;\n\n    constructor(\n        private controls: PolyControls,\n        private object: THREE.Object3D,\n        private shots: ShotManager,\n        private clock: PolyClock\n    ) {\n        this.moveState = getIdleMoveState();\n        this.shotDelta = 0;\n\n        this.orbitSpeed = 0.05;\n        this.rollSpeed = 0.05;\n        this.forwardsAndBackwardsSpeed = 0.5;\n        this.inertiaFactor = 0.1;\n        this.shotRecoveryTime = 0.15;\n\n        this.update();\n    }\n\n    // TODO: Make movement (and probably followCamera) frame independent\n    // See https://github.com/ivoelbert/poly-remake/ssues/2\n    public update = (): void => {\n        // Movement inertia\n        this.moveState = lerpMoveStates(\n            this.moveState,\n            this.controls.moveState,\n            this.inertiaFactor\n        );\n\n        this.updateDepth();\n        this.updateOrbit();\n        this.updateShots();\n    };\n\n    private updateDepth = (): void => {\n        const depthMovement =\n            this.moveState[Movements.backwards] - this.moveState[Movements.forwards];\n        if (Math.abs(depthMovement) > MOVEMENT_EPSILON) {\n            const zOffset = depthMovement * this.forwardsAndBackwardsSpeed;\n\n            let objectRadius = this.object.position.length();\n\n            if (objectRadius + zOffset < MIN_RADIUS) {\n                objectRadius = MIN_RADIUS;\n            } else if (objectRadius + zOffset > MAX_RADIUS) {\n                objectRadius = MAX_RADIUS;\n            } else {\n                objectRadius += zOffset;\n            }\n\n            this.object.position.setLength(objectRadius);\n        }\n    };\n\n    private updateOrbit = (): void => {\n        const xAxis = new THREE.Vector3();\n        const yAxis = new THREE.Vector3();\n        const zAxis = new THREE.Vector3();\n        this.object.matrix.extractBasis(xAxis, yAxis, zAxis);\n\n        const verticalOrbit = this.moveState[Movements.up] - this.moveState[Movements.down];\n        const horizontalOrbit = this.moveState[Movements.right] - this.moveState[Movements.left];\n\n        const verticalVector = xAxis.clone();\n        verticalVector.multiplyScalar(verticalOrbit);\n        const horizontalVector = yAxis.clone();\n        horizontalVector.multiplyScalar(horizontalOrbit);\n\n        const directionVector = new THREE.Vector3()\n            .addVectors(verticalVector, horizontalVector)\n            .clampLength(0, 1);\n        const rotationAngle = directionVector.length();\n\n        if (rotationAngle > MOVEMENT_EPSILON) {\n            directionVector.normalize();\n            this.object.position.applyAxisAngle(directionVector, rotationAngle * this.orbitSpeed);\n        }\n\n        const roll = this.moveState[Movements.rollRight] - this.moveState[Movements.rollLeft];\n        yAxis.applyAxisAngle(zAxis, roll * this.rollSpeed);\n        this.object.up.copy(yAxis);\n        this.object.lookAt(0, 0, 0);\n    };\n\n    private updateShots = (): void => {\n        this.shotDelta += this.clock.getDelta();\n\n        if (this.shotDelta > this.shotRecoveryTime && this.moveState[Movements.shoot] === 1) {\n            this.shotDelta = 0;\n            this.shots.spawn(this.object.position);\n        }\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { MAX_RADIUS } from '../../constants';\nimport { PolyHitbox } from '../hitbox';\n\nexport class PolyShip implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    constructor() {\n        const geometry = this.createGeometry();\n\n        const material = new THREE.MeshBasicMaterial({\n            color: 0xfafafa,\n            wireframe: true,\n        });\n\n        this.mesh = new THREE.Mesh(geometry, material);\n        this.mesh.position.set(0, 0, MAX_RADIUS);\n\n        this.hitbox = new PolyHitbox(this.mesh, geometry);\n    }\n\n    public update = () => {\n        this.hitbox.update();\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        console.log('OH SHIT!');\n    };\n\n    private createGeometry = (): THREE.BufferGeometry => {\n        const geometry = new THREE.BufferGeometry();\n\n        const frontPoint = [0, 0, 1];\n        const backTop = [0, 0.25, 0];\n        const backLeft = [-0.5, -0.25, 0];\n        const backRight = [0.5, -0.25, 0];\n\n        const vertices = new Float32Array([\n            ...frontPoint,\n            ...backTop,\n            ...backLeft,\n\n            ...frontPoint,\n            ...backTop,\n            ...backRight,\n\n            ...frontPoint,\n            ...backLeft,\n            ...backRight,\n\n            ...backTop,\n            ...backLeft,\n            ...backRight,\n        ]);\n\n        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n\n        return geometry;\n    };\n}\n","import * as THREE from 'three';\n\nexport class FollowCamera extends THREE.PerspectiveCamera {\n    private distance: number;\n    private inertiaFactor: number;\n\n    constructor(private followedObject: THREE.Object3D) {\n        super(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n\n        this.distance = 2;\n        this.inertiaFactor = 0.8;\n\n        this.update();\n    }\n\n    // TODO: Make movement (and probably followCamera) frame independent\n    // See https://github.com/ivoelbert/poly-remake/issues/2\n    update = (): void => {\n        const followedPosition = this.followedObject.position.clone();\n        followedPosition.add(followedPosition.clone().normalize().multiplyScalar(this.distance));\n\n        const newPosition = new THREE.Vector3().lerpVectors(\n            this.position,\n            followedPosition,\n            this.inertiaFactor\n        );\n\n        this.position.copy(newPosition);\n        this.up.copy(this.followedObject.up);\n        this.lookAt(0, 0, 0);\n    };\n}\n","import * as THREE from 'three';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\n\nconst BLOOM_PARAMS = {\n    exposure: 1.01,\n    bloomStrength: 1.1,\n    bloomThreshold: 0,\n    bloomRadius: 0,\n};\n\nexport class PolyRenderer {\n    private renderer: THREE.WebGLRenderer;\n    private composer: EffectComposer;\n\n    constructor(scene: THREE.Scene, camera: THREE.Camera) {\n        this.renderer = new THREE.WebGLRenderer();\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.renderer.toneMappingExposure = Math.pow(BLOOM_PARAMS.exposure, 4.0);\n        this.renderer.outputEncoding = THREE.sRGBEncoding;\n\n        const renderScene = new RenderPass(scene, camera);\n\n        const bloomPass = new UnrealBloomPass(\n            new THREE.Vector2(window.innerWidth, window.innerHeight),\n            BLOOM_PARAMS.bloomStrength,\n            BLOOM_PARAMS.bloomRadius,\n            BLOOM_PARAMS.bloomThreshold\n        );\n\n        this.composer = new EffectComposer(this.renderer);\n        this.composer.renderToScreen = false;\n        this.composer.addPass(renderScene);\n        this.composer.addPass(bloomPass);\n\n        this.composer.renderToScreen = true;\n    }\n\n    public getDomElement = (): HTMLCanvasElement => {\n        return this.renderer.domElement;\n    };\n\n    public resize = (): void => {\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.composer.setSize(window.innerWidth, window.innerHeight);\n    };\n\n    public render = (): void => {\n        this.composer.render();\n    };\n}\n","import * as THREE from 'three';\n\nfunction isRenderItem(obj: any): obj is THREE.RenderItem {\n    return 'geometry' in obj && 'material' in obj;\n}\n\nfunction disposeMaterial(obj: THREE.Object3D) {\n    if (!isRenderItem(obj)) return;\n\n    // because obj.material can be a material or array of materials\n    const materials: THREE.Material[] = ([] as THREE.Material[]).concat(obj.material);\n\n    for (const material of materials) {\n        material.dispose();\n    }\n}\n\nexport class PolyScene {\n    public readonly scene: THREE.Scene;\n\n    constructor() {\n        this.scene = new THREE.Scene();\n        this.scene.fog = new THREE.FogExp2(0x000000, 0.000025);\n\n        const light = new THREE.AmbientLight(0xffffff);\n        this.scene.add(light);\n    }\n\n    public add = (...objects: THREE.Object3D[]) => this.scene.add(...objects);\n\n    public remove = (...objects: THREE.Object3D[]) => this.scene.remove(...objects);\n\n    // TODO: Revisit a better disposing solution\n    public dispose = () => {\n        this.scene.traverse((obj) => {\n            if (!obj) {\n                return;\n            }\n\n            if (isRenderItem(obj)) {\n                if (obj.geometry) {\n                    obj.geometry.dispose();\n                }\n                disposeMaterial(obj);\n            }\n\n            // if we remove children in the same tick then we can't continue traversing,\n            // so we defer to the next microtask\n            Promise.resolve().then(() => {\n                obj.parent && obj.parent.remove(obj);\n            });\n        });\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { DropFunction } from '../manager';\nimport { PolyHitbox } from '../hitbox';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { constrain01, easeOutElastic, linearMap } from '../../utils/easing';\nimport { MAX_RADIUS } from '../../constants';\nimport { ExplosionsManager } from '../explosion/manager';\nimport { AsteroidMeshFactory } from './meshFactory';\n\nconst SPAWN_ANIMATION_TIME = 1;\n\nexport class Asteroid implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    private normal: THREE.Vector3;\n    private angularVelocity: number;\n    private radialVelocity: number;\n\n    private epoch: number;\n\n    constructor(\n        meshFactory: AsteroidMeshFactory,\n        private clock: PolyClock,\n        private explosions: ExplosionsManager,\n        private dropObject: DropFunction<Asteroid>\n    ) {\n        this.mesh = meshFactory.buildMesh();\n        this.hitbox = new PolyHitbox(this.mesh, meshFactory.getHitboxGeometry());\n\n        this.normal = new THREE.Vector3(0, 1, 0);\n\n        this.angularVelocity = 1;\n        this.radialVelocity = 1;\n        this.epoch = 0;\n    }\n\n    public spawn = (position: THREE.Vector3, normal: THREE.Vector3): void => {\n        this.mesh.position.copy(position);\n        this.normal = normal;\n        this.epoch = this.clock.getElapsed();\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        this.drop();\n    };\n\n    public update = (): void => {\n        const delta = this.clock.getDelta();\n        const elapsed = this.clock.getElapsed();\n\n        const lifeTime = elapsed - this.epoch;\n        const timeFactor = constrain01(linearMap(lifeTime, 0, SPAWN_ANIMATION_TIME, 0, 1));\n        const easedTimeFactor = easeOutElastic(timeFactor);\n\n        this.mesh.scale.set(easedTimeFactor, easedTimeFactor, easedTimeFactor);\n\n        // Rotation\n        const angleToRotate = this.angularVelocity * delta;\n        this.mesh.position.applyAxisAngle(this.normal, angleToRotate);\n\n        // radial movement\n        const currentLength = this.mesh.position.length();\n        const lengthOffset = this.radialVelocity * delta;\n        this.mesh.position.setLength(currentLength + lengthOffset);\n\n        this.hitbox.update();\n\n        if (tooFarFromCenter(this.mesh.position)) {\n            this.drop();\n        }\n    };\n\n    private drop = () => {\n        this.explosions.spawn(this.mesh.position.clone());\n        this.dropObject(this);\n    };\n}\n\nfunction tooFarFromCenter(point: THREE.Vector3): boolean {\n    return point.length() > MAX_RADIUS;\n}\n","import * as THREE from 'three';\n\nexport class AsteroidMeshFactory {\n    private mesh: THREE.Mesh;\n    private hitboxGeometry: THREE.BufferGeometry;\n\n    constructor() {\n        this.hitboxGeometry = new THREE.DodecahedronBufferGeometry(1.5);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0x2bfa2b,\n            wireframe: true,\n        });\n\n        this.mesh = new THREE.Mesh(this.hitboxGeometry, material);\n    }\n\n    public buildMesh = (): THREE.Mesh => {\n        return this.mesh.clone() as THREE.Mesh;\n    };\n\n    public getHitboxGeometry = (): THREE.BufferGeometry => {\n        return this.hitboxGeometry.clone();\n    };\n}\n","import { PolyObject } from './objects/polyObject';\n\nexport enum Groups {\n    asteroids,\n    ship,\n    shots,\n    missiles,\n    center,\n}\n\ninterface Collider {\n    addRule: (g1: Groups, g2: Groups) => void;\n    addObjectToGroup: (obj: PolyObject, group: Groups) => void;\n    removeObjectFromGroup: (obj: PolyObject, group: Groups) => void;\n    update: () => void;\n}\n\ntype ColliderGroups = Record<Groups, Set<PolyObject>>;\n\nexport class PolyCollider implements Collider {\n    private rules: Set<[Groups, Groups]>;\n    private groups: ColliderGroups;\n\n    constructor() {\n        this.rules = new Set();\n        this.groups = {\n            [Groups.asteroids]: new Set(),\n            [Groups.ship]: new Set(),\n            [Groups.shots]: new Set(),\n            [Groups.missiles]: new Set(),\n            [Groups.center]: new Set(),\n        };\n    }\n\n    addRule = (g1: Groups, g2: Groups): void => {\n        this.rules.add([g1, g2]);\n    };\n\n    addObjectToGroup = (obj: PolyObject, group: Groups): void => {\n        this.groups[group].add(obj);\n    };\n\n    removeObjectFromGroup = (obj: PolyObject, group: Groups): void => {\n        this.groups[group].delete(obj);\n    };\n\n    update = (): void => {\n        this.rules.forEach(([g1, g2]) => {\n            this.groups[g1].forEach((o1) => {\n                this.groups[g2].forEach((o2) => {\n                    if (polyObjectsCollide(o1, o2)) {\n                        o1.onCollide?.(o2);\n                        o2.onCollide?.(o1);\n                    }\n                });\n            });\n        });\n    };\n}\n\nconst polyObjectsCollide = (o1: PolyObject, o2: PolyObject): boolean => {\n    return o1.hitbox.intersects(o2.hitbox);\n};\n","import { Vector3 } from 'three';\nimport { Asteroid } from './asteroid';\nimport { PolyScene } from '../../scene/PolyScene';\nimport {\n    repeat,\n    getDumpster,\n    randomUnitVector,\n    assertExists,\n    getOne,\n    randomOrthogonalUnitVector,\n} from '../../utils/utils';\nimport { ASTEROIDS_IN_SCENE, CENTER_RADIUS } from '../../constants';\nimport { Manager } from '../manager';\nimport { AsteroidMeshFactory } from './meshFactory';\nimport { PolyCollider, Groups } from '../../collider';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ExplosionsManager } from '../explosion/manager';\n\nexport class AsteroidManager implements Manager<Asteroid> {\n    private idleObjects: Set<Asteroid>;\n    private liveObjects: Set<Asteroid>;\n    private intervalId: NodeJS.Timeout | null;\n\n    constructor(\n        private scene: PolyScene,\n        private collider: PolyCollider,\n        private clock: PolyClock,\n        private explosions: ExplosionsManager\n    ) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n\n        const meshFactory = new AsteroidMeshFactory();\n        repeat(ASTEROIDS_IN_SCENE, (_) => {\n            const object = new Asteroid(meshFactory, this.clock, this.explosions, this.drop);\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n        this.intervalId = null;\n    }\n\n    public start = () => {\n        this.intervalId = setInterval(this.spawnRandom, 3000);\n    };\n\n    public spawn = (position: Vector3, normal: Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position, normal);\n\n        this.collider.addObjectToGroup(objectToSpawn, Groups.asteroids);\n    };\n\n    public drop = (objectToDelete: Asteroid) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n\n        this.collider.removeObjectFromGroup(objectToDelete, Groups.asteroids);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n\n        if (this.intervalId !== null) {\n            clearTimeout(this.intervalId);\n        }\n    };\n\n    private spawnRandom = (): void => {\n        const normal = randomUnitVector();\n        const position = randomOrthogonalUnitVector(normal).setLength(CENTER_RADIUS);\n\n        this.spawn(position, normal);\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { randomUnitVector, MathUtils } from '../../utils/utils';\nimport { MissileMeshFactory } from './meshFactory';\nimport { DropFunction } from '../manager';\nimport { PolyHitbox } from '../hitbox';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ExplosionsManager } from '../explosion/manager';\n\nconst MISSILE_LIFETIME = 7;\n\nexport class FollowMissile implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    private direction: THREE.Vector3;\n    private angSpeed: number;\n    private speed: number;\n\n    private epoch: number;\n\n    constructor(\n        private object: THREE.Object3D,\n        private clock: PolyClock,\n        private explosions: ExplosionsManager,\n        meshFactory: MissileMeshFactory,\n        private dropObject: DropFunction<FollowMissile>\n    ) {\n        this.angSpeed = 3;\n        this.speed = 40;\n\n        this.mesh = meshFactory.buildMesh();\n        this.direction = randomUnitVector();\n\n        this.hitbox = new PolyHitbox(this.mesh, meshFactory.getHitboxGeometry());\n        this.epoch = 0;\n    }\n\n    public spawn = (position: THREE.Vector3, direction: THREE.Vector3): void => {\n        this.epoch = this.clock.getElapsed();\n        this.mesh.position.copy(position);\n        this.direction.copy(direction);\n        this.direction.normalize();\n\n        this.align();\n    };\n\n    public update = (): void => {\n        this.updateRotation();\n        this.updatePosition();\n        this.updateFlames();\n\n        this.hitbox.update();\n\n        const elapsed = this.clock.getElapsed();\n        const lifeTime = elapsed - this.epoch;\n\n        if (lifeTime > MISSILE_LIFETIME) {\n            this.drop();\n        }\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        this.drop();\n    };\n\n    private updateRotation = (): void => {\n        const delta = this.clock.getDelta();\n        const towards = this.object.position.clone();\n        towards.sub(this.mesh.position);\n\n        const angle = this.direction.angleTo(towards);\n        const clampedAngle = MathUtils.clamp(angle, -this.angSpeed * delta, this.angSpeed * delta);\n\n        const normal = new THREE.Vector3().crossVectors(towards, this.direction);\n        normal.normalize();\n\n        this.direction.applyAxisAngle(normal, -clampedAngle);\n        this.align();\n    };\n\n    private updatePosition = (): void => {\n        const delta = this.clock.getDelta();\n        const step = this.direction.clone();\n        step.multiplyScalar(this.speed * delta);\n\n        this.mesh.position.add(step);\n    };\n\n    private updateFlames = (): void => {\n        const delta = this.clock.getDelta();\n        const elapsed = this.clock.getElapsed();\n        this.mesh.children[0].scale.y += Math.sin(elapsed * 10) * 0.05;\n        this.mesh.children[0].rotateY(delta * 10);\n        this.mesh.children[1].scale.y -= Math.cos(elapsed * 10) * 0.05;\n        this.mesh.children[1].rotateY(delta * 10);\n    };\n\n    private align = (): void => {\n        const lookAtPos = this.mesh.position.clone();\n        lookAtPos.add(this.direction);\n        this.mesh.lookAt(lookAtPos);\n        this.mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI * 0.5);\n    };\n\n    private drop = () => {\n        this.explosions.spawn(this.mesh.position.clone());\n        this.dropObject(this);\n    };\n}\n","import * as THREE from 'three';\n\nexport class MissileMeshFactory {\n    private mesh: THREE.Mesh;\n    private hitboxGeometry: THREE.BufferGeometry;\n\n    constructor() {\n        this.hitboxGeometry = new THREE.CylinderBufferGeometry(0.2, 0.4, 1, 6, 1);\n        const misilMaterial = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0xffffff,\n        });\n\n        const fireGeom = new THREE.ConeBufferGeometry(0.3, 1, 6);\n\n        const lightFireMat = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0xeeec74,\n        });\n\n        const darkFireMat = new THREE.MeshBasicMaterial({\n            wireframe: true,\n            color: 0xee5137,\n        });\n\n        const lightFire = new THREE.Mesh(fireGeom, lightFireMat);\n        const darkFire = new THREE.Mesh(fireGeom, darkFireMat);\n        lightFire.position.y -= 1;\n        darkFire.position.y -= 1;\n        lightFire.rotateX(Math.PI);\n        darkFire.rotateX(Math.PI);\n\n        this.mesh = new THREE.Mesh(this.hitboxGeometry, misilMaterial);\n        this.mesh.add(lightFire);\n        this.mesh.add(darkFire);\n    }\n\n    public buildMesh = (): THREE.Mesh => {\n        return this.mesh.clone() as THREE.Mesh;\n    };\n\n    public getHitboxGeometry = (): THREE.BufferGeometry => {\n        return this.hitboxGeometry.clone();\n    };\n}\n","import { Vector3 } from 'three';\nimport { FollowMissile } from './followMissile';\nimport { PolyScene } from '../../scene/PolyScene';\nimport {\n    repeat,\n    getDumpster,\n    getOne,\n    assertExists,\n    randomUnitVector,\n    getOrigin,\n} from '../../utils/utils';\nimport { MISSILES_IN_SCENE } from '../../constants';\nimport { Manager } from '../manager';\nimport { MissileMeshFactory } from './meshFactory';\nimport { PolyCollider, Groups } from '../../collider';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ExplosionsManager } from '../explosion/manager';\n\nexport class FollowMissileManager implements Manager<FollowMissile> {\n    private idleObjects: Set<FollowMissile>;\n    private liveObjects: Set<FollowMissile>;\n    private intervalId: NodeJS.Timeout | null;\n\n    constructor(\n        private scene: PolyScene,\n        followedObject: THREE.Object3D,\n        private clock: PolyClock,\n        private collider: PolyCollider,\n        explosions: ExplosionsManager\n    ) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n        const meshFactory = new MissileMeshFactory();\n\n        repeat(MISSILES_IN_SCENE, (_) => {\n            const object = new FollowMissile(\n                followedObject,\n                this.clock,\n                explosions,\n                meshFactory,\n                this.drop\n            );\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n        this.intervalId = null;\n    }\n\n    public start = () => {\n        const initialPosition = getOrigin();\n        this.spawn(initialPosition, randomUnitVector());\n        this.intervalId = setInterval(() => this.spawn(initialPosition, randomUnitVector()), 10000);\n    };\n\n    public spawn = (position: Vector3, direction: Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position, direction);\n\n        this.collider.addObjectToGroup(objectToSpawn, Groups.missiles);\n    };\n\n    public drop = (objectToDelete: FollowMissile) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n\n        this.collider.removeObjectFromGroup(objectToDelete, Groups.missiles);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n\n        if (this.intervalId !== null) {\n            clearInterval(this.intervalId);\n        }\n    };\n}\n","import * as THREE from 'three';\nimport { PolyObject } from '../polyObject';\nimport { DropFunction } from '../manager';\nimport { CENTER_RADIUS } from '../../constants';\nimport { PolyHitbox } from '../hitbox';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { ShotMeshFactory } from './meshFactory';\n\nexport class Shot implements PolyObject {\n    public mesh: THREE.Object3D;\n    public hitbox: PolyHitbox;\n\n    private speed: number;\n\n    constructor(\n        meshFactory: ShotMeshFactory,\n        private clock: PolyClock,\n        private dropObject: DropFunction<Shot>\n    ) {\n        this.mesh = meshFactory.buildMesh();\n        this.hitbox = new PolyHitbox(this.mesh, meshFactory.getHitboxGeometry());\n\n        this.speed = 200;\n    }\n\n    public spawn = (position: THREE.Vector3): void => {\n        this.mesh.position.copy(position);\n    };\n\n    public onCollide = (who: PolyObject): void => {\n        this.drop();\n    };\n\n    public update = (): void => {\n        const delta = this.clock.getDelta();\n\n        const currentLength = this.mesh.position.length();\n        const lengthOffset = this.speed * delta;\n        this.mesh.position.setLength(currentLength - lengthOffset);\n\n        this.hitbox.update();\n\n        if (this.mesh.position.length() <= CENTER_RADIUS) {\n            this.drop();\n        }\n    };\n\n    private drop = () => {\n        this.dropObject(this);\n    };\n}\n","import * as THREE from 'three';\n\nexport class ShotMeshFactory {\n    private mesh: THREE.Mesh;\n    private hitboxGeometry: THREE.BufferGeometry;\n\n    constructor() {\n        const coreGeometry = new THREE.DodecahedronBufferGeometry(0.15);\n        const coreMaterial = new THREE.MeshBasicMaterial({\n            color: 0xfff36e,\n            wireframe: true,\n        });\n\n        const coreMesh = new THREE.Mesh(coreGeometry, coreMaterial);\n\n        this.hitboxGeometry = new THREE.DodecahedronBufferGeometry(0.3);\n        const material = new THREE.MeshBasicMaterial({\n            color: 0xd68400,\n            wireframe: true,\n        });\n\n        this.mesh = new THREE.Mesh(this.hitboxGeometry, material);\n        this.mesh.add(coreMesh);\n    }\n\n    public buildMesh = (): THREE.Mesh => {\n        return this.mesh.clone() as THREE.Mesh;\n    };\n\n    public getHitboxGeometry = (): THREE.BufferGeometry => {\n        return this.hitboxGeometry.clone();\n    };\n}\n","import * as THREE from 'three';\nimport { Shot } from './shot';\nimport { PolyScene } from '../../scene/PolyScene';\nimport { repeat, getDumpster, getOne, assertExists } from '../../utils/utils';\nimport { SHOTS_IN_SCENE } from '../../constants';\nimport { Manager } from '../manager';\nimport { ShotMeshFactory } from './meshFactory';\nimport { PolyCollider, Groups } from '../../collider';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { SoundManager } from '../../soundManager';\n\nexport class ShotManager implements Manager<Shot> {\n    private idleObjects: Set<Shot>;\n    private liveObjects: Set<Shot>;\n\n    constructor(\n        private scene: PolyScene,\n        private collider: PolyCollider,\n        private clock: PolyClock,\n        private sounds: SoundManager\n    ) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n\n        const meshFactory = new ShotMeshFactory();\n        repeat(SHOTS_IN_SCENE, (_) => {\n            const object = new Shot(meshFactory, this.clock, this.drop);\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n    }\n\n    public spawn = (position: THREE.Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position);\n\n        this.collider.addObjectToGroup(objectToSpawn, Groups.shots);\n\n        this.sounds.playShot();\n    };\n\n    public drop = (objectToDelete: Shot) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n\n        this.collider.removeObjectFromGroup(objectToDelete, Groups.shots);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n    };\n}\n","import * as THREE from 'three';\nimport { PolyClock } from '../../clock/PolyClock';\nimport { CENTER_RADIUS } from '../../constants';\nimport { constrain01, linearMap } from '../../utils/easing';\nimport { noop, randFloat } from '../../utils/utils';\nimport { Hitbox, NoCollisionsHitbox } from '../hitbox';\nimport { DropFunction } from '../manager';\nimport { PolyObject } from '../polyObject';\nimport { ExplosionMesh, ExplosionMeshFactory } from './meshFactory';\n\nconst FRAGMENT_LIFETIME = 1;\n\nexport class Explosion implements PolyObject {\n    public hitbox: Hitbox;\n\n    private explosionMesh: ExplosionMesh;\n    private epoch: number;\n    private fragmentSpeeds: number[];\n\n    constructor(\n        meshFactory: ExplosionMeshFactory,\n        private clock: PolyClock,\n        private dropObject: DropFunction<Explosion>\n    ) {\n        this.explosionMesh = meshFactory.buildMesh();\n        this.hitbox = new NoCollisionsHitbox();\n\n        this.epoch = 0;\n        this.fragmentSpeeds = this.getRandomSpeeds();\n    }\n\n    get mesh(): THREE.Mesh {\n        return this.explosionMesh.mesh;\n    }\n\n    spawn = (position: THREE.Vector3): void => {\n        this.mesh.position.copy(position);\n        this.epoch = this.clock.getElapsed();\n        this.fragmentSpeeds = this.getRandomSpeeds();\n        this.explosionMesh.traverseFragments((fragment) => {\n            fragment.setRadiusToCenter(0.1);\n        });\n    };\n\n    onCollide = noop;\n\n    update = (): void => {\n        const elapsed = this.clock.getElapsed();\n        const delta = this.clock.getDelta();\n        const lifeTime = elapsed - this.epoch;\n\n        this.explosionMesh.traverseFragments((fragment, idx) => {\n            const speed = this.fragmentSpeeds[idx];\n            fragment.extendRadius(delta * speed);\n        });\n\n        const materialLifetimeFactor = constrain01(linearMap(lifeTime, 0, FRAGMENT_LIFETIME, 0, 1));\n        this.explosionMesh.updateMaterial(materialLifetimeFactor);\n\n        if (lifeTime > FRAGMENT_LIFETIME) {\n            this.drop();\n        }\n    };\n\n    private getRandomSpeeds = (): number[] => {\n        const speeds: number[] = [];\n        this.explosionMesh.traverseFragments((_) => {\n            const speed = randFloat(0.5 * CENTER_RADIUS, 1 * CENTER_RADIUS);\n            speeds.push(speed);\n        });\n        return speeds;\n    };\n\n    private drop = () => {\n        this.dropObject(this);\n    };\n}\n","import * as THREE from 'three';\nimport { CENTER_RADIUS } from '../../constants';\nimport { randFloat, randomUnitVector } from '../../utils/utils';\n\nconst FRAGMENT_INITIAL_COLOR = new THREE.Color(0xffff96);\nconst FRAGMENT_END_COLOR = new THREE.Color(0x610200);\n\nexport class ExplosionFragmentMesh {\n    public mesh: THREE.Mesh;\n\n    constructor(material: THREE.MeshBasicMaterial) {\n        const fragmentSize = randFloat(CENTER_RADIUS * 0.05, CENTER_RADIUS * 0.2);\n        const fragmentGeometry = new THREE.TetrahedronBufferGeometry(fragmentSize);\n\n        this.mesh = new THREE.Mesh(fragmentGeometry, material);\n    }\n\n    setPosition = (x: number, y: number, z: number) => {\n        this.mesh.position.set(x, y, z);\n    };\n\n    setRadiusToCenter = (r: number) => {\n        this.mesh.position.setLength(r);\n    };\n\n    extendRadius = (amount: number) => {\n        const dir = this.mesh.position.clone().setLength(amount);\n        this.mesh.position.add(dir);\n    };\n}\n\nexport class ExplosionMesh {\n    public mesh: THREE.Mesh;\n    private fragments: ExplosionFragmentMesh[];\n    private fragmentMaterial: THREE.MeshBasicMaterial;\n\n    constructor() {\n        this.mesh = new THREE.Mesh();\n\n        this.fragmentMaterial = new THREE.MeshBasicMaterial({\n            color: FRAGMENT_INITIAL_COLOR,\n            wireframe: true,\n            transparent: true,\n        });\n\n        this.fragments = this.buildFragments();\n\n        const rotationAngle = randFloat(0, 2 * Math.PI);\n        this.mesh.rotateOnAxis(randomUnitVector(), rotationAngle);\n    }\n\n    traverseFragments = (cb: (fragment: ExplosionFragmentMesh, idx: number) => void) => {\n        this.fragments.forEach((fragment, idx) => cb(fragment, idx));\n    };\n\n    updateMaterial = (lifetimeFactor: number) => {\n        const opacity = 1 - lifetimeFactor;\n        const color = new THREE.Color(FRAGMENT_INITIAL_COLOR).lerp(\n            FRAGMENT_END_COLOR,\n            lifetimeFactor\n        );\n\n        this.fragmentMaterial.opacity = opacity;\n        this.fragmentMaterial.color = color;\n    };\n\n    private buildFragments = (): ExplosionFragmentMesh[] => {\n        const initialPositions = new THREE.SphereGeometry(0.1, 6, 6).getAttribute('position');\n\n        const fragments: ExplosionFragmentMesh[] = [];\n        for (let i = 0; i < initialPositions.count; i++) {\n            const x = initialPositions.getX(i);\n            const y = initialPositions.getY(i);\n            const z = initialPositions.getZ(i);\n\n            const fragment = new ExplosionFragmentMesh(this.fragmentMaterial);\n            fragment.setPosition(x, y, z);\n            this.mesh.add(fragment.mesh);\n            fragments.push(fragment);\n        }\n\n        return fragments;\n    };\n}\n\nexport class ExplosionMeshFactory {\n    public buildMesh = (): ExplosionMesh => {\n        return new ExplosionMesh();\n    };\n}\n","import { PolyClock } from '../../clock/PolyClock';\nimport { EXPLOSIONS_IN_SCENE } from '../../constants';\nimport { PolyScene } from '../../scene/PolyScene';\nimport { assertExists, getDumpster, getOne, repeat } from '../../utils/utils';\nimport { Manager } from '../manager';\nimport { Explosion } from './explosion';\nimport { ExplosionMeshFactory } from './meshFactory';\n\nexport class ExplosionsManager implements Manager<Explosion> {\n    private idleObjects: Set<Explosion>;\n    private liveObjects: Set<Explosion>;\n\n    constructor(private scene: PolyScene, private clock: PolyClock) {\n        this.idleObjects = new Set();\n        this.liveObjects = new Set();\n\n        const meshFactory = new ExplosionMeshFactory();\n        repeat(EXPLOSIONS_IN_SCENE, (_) => {\n            const object = new Explosion(meshFactory, this.clock, this.drop);\n            object.mesh.position.copy(getDumpster());\n            this.idleObjects.add(object);\n        });\n\n        this.idleObjects.forEach((object) => this.scene.add(object.mesh));\n    }\n\n    public spawn = (position: THREE.Vector3) => {\n        // If no available objects blow up. In the future we should do better.\n        // A FIFO structure that drops the oldest element and spawns the new one.\n        const objectToSpawn = assertExists(getOne(this.idleObjects));\n\n        this.idleObjects.delete(objectToSpawn);\n        this.liveObjects.add(objectToSpawn);\n\n        objectToSpawn.spawn(position);\n    };\n\n    public drop = (objectToDelete: Explosion) => {\n        objectToDelete.mesh.position.copy(getDumpster());\n        this.liveObjects.delete(objectToDelete);\n        this.idleObjects.add(objectToDelete);\n    };\n\n    public update = () => {\n        this.liveObjects.forEach((object) => object.update());\n    };\n\n    public dispose = () => {\n        this.liveObjects.forEach((object) => this.scene.remove(object.mesh));\n        this.idleObjects.forEach((object) => this.scene.remove(object.mesh));\n    };\n}\n","import * as Tone from 'tone';\nimport { noop } from './utils/utils';\n\nexport interface SoundManager {\n    playShot(): void;\n    playPickup(): void;\n    dispose(): void;\n}\n\nexport class SilentSoundManager implements SoundManager {\n    playShot = noop;\n    playPickup = noop;\n    dispose = noop;\n}\n\nexport class ToneSoundManager implements SoundManager {\n    private synth: Tone.Synth;\n\n    constructor() {\n        this.synth = new Tone.Synth().toDestination();\n    }\n\n    playShot = () => {\n        const now = Tone.now();\n        this.synth.triggerAttackRelease('G1', '32n', now);\n    };\n\n    playPickup = () => {\n        const now = Tone.now();\n        this.synth.triggerAttackRelease('C5', '32n', now);\n        this.synth.triggerAttackRelease('E5', '32n', now + 0.05);\n        this.synth.triggerAttackRelease('G5', '32n', now + 0.1);\n    };\n\n    dispose = () => {\n        this.synth.dispose();\n    };\n}\n","import { Stars } from './objects/stars/stars';\nimport { consoleInfo } from './utils/utils';\nimport { Center } from './objects/center';\nimport { KeyboardControls } from './controls/keyboardControls';\nimport { PolyClock } from './clock/PolyClock';\nimport { ObjectController } from './controls/objectController';\nimport { PolyShip } from './objects/ship/ship';\nimport { FollowCamera } from './objects/followCamera';\nimport { PolyRenderer } from './renderer';\nimport { PolyScene } from './scene/PolyScene';\nimport { AsteroidManager } from './objects/asteroid/manager';\nimport { FollowMissileManager } from './objects/followMissile/manager';\nimport { ShotManager } from './objects/shots/manager';\nimport { PolyCollider, Groups } from './collider';\nimport { ExplosionsManager } from './objects/explosion/manager';\nimport { SilentSoundManager, SoundManager } from './soundManager';\n\nexport class Polybius {\n    private renderer: PolyRenderer;\n    private clock: PolyClock;\n    private camera: FollowCamera;\n    private keyboardControls: KeyboardControls;\n    private objectController: ObjectController;\n    private center: Center;\n    private ship: PolyShip;\n    private scene: PolyScene;\n    private explosions: ExplosionsManager;\n    private asteroids: AsteroidManager;\n    private missiles: FollowMissileManager;\n    private shots: ShotManager;\n    private collider: PolyCollider;\n    private sounds: SoundManager;\n\n    constructor() {\n        // Set up the scene\n        this.scene = new PolyScene();\n\n        // Set up the clock\n        this.clock = new PolyClock();\n\n        // Set up the collider\n        this.collider = new PolyCollider();\n        this.collider.addRule(Groups.asteroids, Groups.ship);\n        this.collider.addRule(Groups.shots, Groups.asteroids);\n        this.collider.addRule(Groups.shots, Groups.center);\n        this.collider.addRule(Groups.shots, Groups.missiles);\n        this.collider.addRule(Groups.missiles, Groups.ship);\n\n        /**\n         * TODO: iron out sounds and use the ToneSoundManager\n         */\n        this.sounds = new SilentSoundManager();\n\n        this.explosions = new ExplosionsManager(this.scene, this.clock);\n\n        // Set up the ship\n        this.ship = new PolyShip();\n        this.collider.addObjectToGroup(this.ship, Groups.ship);\n\n        // Set up camera\n        this.camera = new FollowCamera(this.ship.mesh);\n\n        // Set up the renderer\n        this.renderer = new PolyRenderer(this.scene.scene, this.camera);\n        this.renderer.resize();\n\n        // Set up various objects and managers\n        const stars = new Stars();\n        this.center = new Center(this.clock);\n        this.collider.addObjectToGroup(this.center, Groups.center);\n\n        this.scene.add(this.ship.mesh, stars.mesh, this.center.mesh);\n\n        this.asteroids = new AsteroidManager(\n            this.scene,\n            this.collider,\n            this.clock,\n            this.explosions\n        );\n        this.missiles = new FollowMissileManager(\n            this.scene,\n            this.ship.mesh,\n            this.clock,\n            this.collider,\n            this.explosions\n        );\n        this.shots = new ShotManager(this.scene, this.collider, this.clock, this.sounds);\n\n        /**\n         * TODO: iron out the orientation controls and figure out what controls to use\n         * or provide a way to use both.\n         */\n        this.keyboardControls = new KeyboardControls();\n        this.objectController = new ObjectController(\n            this.keyboardControls,\n            this.ship.mesh,\n            this.shots,\n            this.clock\n        );\n    }\n\n    public start = (): void => {\n        this.keyboardControls.attachListeners();\n        window.addEventListener('resize', this.resize);\n\n        this.asteroids.start();\n        this.missiles.start();\n\n        // Start the render loop!\n        consoleInfo('Game started!');\n        this.animate();\n    };\n\n    public dispose = (): void => {\n        this.keyboardControls.dispose();\n        this.asteroids.dispose();\n        this.missiles.dispose();\n        this.explosions.dispose();\n        this.sounds.dispose();\n\n        this.scene.dispose();\n        window.removeEventListener('resize', this.resize);\n    };\n\n    public getDomElement = (): HTMLCanvasElement => {\n        return this.renderer.getDomElement();\n    };\n\n    private resize = (): void => {\n        this.renderer.resize();\n        this.camera.aspect = window.innerWidth / window.innerHeight;\n        this.camera.updateProjectionMatrix();\n    };\n\n    // This function represents a frame. It's called once for every frame.\n    private animate = (): void => {\n        this.clock.tick();\n\n        this.objectController.update();\n        this.ship.update();\n        this.center.update();\n\n        this.missiles.update();\n        this.asteroids.update();\n        this.shots.update();\n        this.explosions.update();\n\n        this.collider.update();\n\n        this.camera.update();\n        this.renderer.render();\n        requestAnimationFrame(this.animate);\n    };\n}\n","import { useEffect } from 'react';\nimport { Polybius } from '../game/polybius';\nimport { assertExists } from '../game/utils/utils';\nimport { useLazyRef } from './useLazyRef';\n\ntype CallbackRef = (element: HTMLElement | null) => void;\n\nexport const usePolybius = (): CallbackRef => {\n    const polybius = useLazyRef(() => new Polybius());\n\n    useEffect(() => {\n        polybius.start();\n\n        return () => polybius.dispose();\n    }, [polybius]);\n\n    const callbackRef = (element: HTMLElement | null): void => {\n        assertExists(element).appendChild(polybius.getDomElement());\n    };\n\n    return callbackRef;\n};\n","import { useRef } from 'react';\n\nexport type InitRef<T> = () => T;\n\nexport function useLazyRef<T>(init: InitRef<T>) {\n    const ref = useRef<T | null>(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n\n    return ref.current;\n}\n","import * as React from 'react';\nimport { usePolybius } from './hooks/usePolybius';\n\nfunction GameComponent() {\n    const polybiusRef = usePolybius();\n\n    return <div className=\"game-container\" ref={polybiusRef} />;\n}\n\nexport default GameComponent;\n"],"sourceRoot":""}